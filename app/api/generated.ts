/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * Badging App API (v0)
 * v0 OpenAPI spec for org/staff/learner/badge/collection management with JWT auth + RBAC. Auth is enforced by required permissions (vendor extension `x-permissions`) and org-scope checks.

 * OpenAPI spec version: 0.2.2
 */
import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

/**
 * ISO 8601 date-time string.
 */
export type ISODateTime = string;

/**
 * Pagination metadata included in all list responses.
 */
export interface PagedMeta {
  /** Current page number. */
  page: number;
  /** Items per page. */
  pageSize: number;
  /** Total number of items. */
  total: number;
}

/**
 * Standard error envelope returned for all non-2xx responses.
 */
export interface ErrorResponse {
  /** Human-readable error message. */
  message: string;
  /** Machine-readable error code for programmatic handling. */
  code?: string;
}

/**
 * Payload for user registration.
 */
export interface RegisterRequest {
  /** User's email address. Must be unique. */
  email: string;
  /**
   * Account password.
   * @minLength 8
   * @maxLength 128
   */
  password: string;
  /**
   * User's display name.
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
}

/**
 * Payload for user login.
 */
export interface LoginRequest {
  /** Registered email address. */
  email: string;
  /** Account password. */
  password: string;
}

/**
 * Payload for token refresh.
 */
export interface RefreshRequest {
  /** The refresh token issued during login or a previous refresh. */
  refreshToken: string;
}

/**
 * Optional social/professional links for a user profile.
 */
export interface SocialLinks {
  /** LinkedIn profile URL. */
  linkedin?: string;
  /** Personal or professional website. */
  website?: string;
  /** X (Twitter) profile URL. */
  x?: string;
}

/**
 * A platform user account.
 */
export interface User {
  /** Unique user identifier. */
  id: string;
  /** User's email address. */
  email: string;
  /** User's display name. */
  name?: string;
  /** URL to the user's profile picture. */
  profileImageUrl?: string;
  /** URL to the user's cover/banner image. */
  coverImageUrl?: string;
  /**
   * Short biography or description.
   * @maxLength 500
   */
  bio?: string;
  /**
   * Professional title or role.
   * @maxLength 120
   */
  title?: string;
  /**
   * City, region, or general location.
   * @maxLength 120
   */
  location?: string;
  socialLinks?: SocialLinks;
  createdAt?: ISODateTime;
}

/**
 * Returned on successful authentication (login, register, or refresh).
 */
export interface AuthResponse {
  /** Short-lived JWT access token for API authorization. */
  accessToken: string;
  /** Long-lived refresh token for obtaining new access tokens. */
  refreshToken?: string;
  user: User;
}

/**
 * Per-user preference settings.
 */
export interface UserSettings {
  /** Preferred locale for the UI. */
  locale?: string;
  /** Whether the user has opted in to marketing emails. */
  marketingEmails?: boolean;
}

/**
 * Partial update for user settings.
 */
export interface UserSettingsUpdateRequest {
  locale?: string;
  marketingEmails?: boolean;
}

export interface PagedUsers {
  meta: PagedMeta;
  data: User[];
}

/**
 * An organization that manages staff, learners, and badge issuance.
 */
export interface Org {
  /** Unique organization identifier. */
  id: string;
  /** Organization display name. */
  name: string;
  /**
   * URL-friendly unique identifier for the organization.
   * @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$
   */
  slug: string;
  /** Short description or bio for the organization. */
  about?: string;
  /** URL to the organization's logo or avatar image. */
  imageUrl?: string;
  /** URL to the organization's cover/banner image. */
  coverImageUrl?: string;
  /** Public contact email for the organization. */
  contactEmail?: string;
  /**
   * Public contact phone number.
   * @maxLength 30
   */
  phone?: string;
  /** Organization website URL. */
  website?: string;
  /**
   * City, region, or general address.
   * @maxLength 200
   */
  location?: string;
  socialLinks?: SocialLinks;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * Payload for creating an organization.
 */
export interface OrgCreateRequest {
  /**
   * Organization name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * URL-friendly identifier. Auto-generated from name if omitted.
   * @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$
   */
  slug?: string;
  /**
   * Short description of the organization.
   * @maxLength 2000
   */
  about?: string;
  /** Cover/banner image URL. */
  coverImageUrl?: string;
  /** Public contact email. */
  contactEmail?: string;
  /**
   * Public phone number.
   * @maxLength 30
   */
  phone?: string;
  /** Organization website. */
  website?: string;
  /**
   * City or region.
   * @maxLength 200
   */
  location?: string;
  socialLinks?: SocialLinks;
}

/**
 * Partial update for an organization's profile.
 */
export interface OrgUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$ */
  slug?: string;
  /** @maxLength 2000 */
  about?: string;
  imageUrl?: string;
  coverImageUrl?: string;
  contactEmail?: string;
  /** @maxLength 30 */
  phone?: string;
  website?: string;
  /** @maxLength 200 */
  location?: string;
  socialLinks?: SocialLinks;
}

/**
 * Organization-level settings controlling membership policies.
 */
export interface OrgSettings {
  /** Whether users can join this org without an invite. */
  allowSelfJoin: boolean;
  /** Whether join requests require admin approval. */
  requireAdminApprovalForJoin: boolean;
  /** Default role assigned to new members. */
  defaultMemberRole?: string;
}

/**
 * Partial update for organization settings.
 */
export interface OrgSettingsUpdateRequest {
  allowSelfJoin?: boolean;
  requireAdminApprovalForJoin?: boolean;
  defaultMemberRole?: string;
}

/**
 * Aggregated statistics for an organization.
 */
export interface OrgStats {
  /** Total active staff members. */
  totalMembers: number;
  /** Total learners affiliated with the org. */
  totalLearners: number;
  /** Total badge definitions created by the org. */
  totalBadges: number;
  /** Total badges issued to learners. */
  totalIssuances: number;
  /** Learners with active status. */
  activeLearners: number;
  /** Badges issued in the current calendar month. */
  badgesIssuedThisMonth: number;
  /** Badges issued in the current calendar year. */
  badgesIssuedThisYear: number;
}

export interface PagedOrgs {
  meta: PagedMeta;
  data: Org[];
}

/**
 * The member's role within the org.
 */
export type OrgMemberRole = typeof OrgMemberRole[keyof typeof OrgMemberRole];


export const OrgMemberRole = {
  owner: 'owner',
  admin: 'admin',
  issuer: 'issuer',
  viewer: 'viewer',
} as const;

/**
 * Current membership status.
 */
export type OrgMemberStatus = typeof OrgMemberStatus[keyof typeof OrgMemberStatus];


export const OrgMemberStatus = {
  active: 'active',
  invited: 'invited',
  suspended: 'suspended',
} as const;

/**
 * A staff membership record linking a user to an organization with a specific role.
 */
export interface OrgMember {
  /** Unique membership record identifier. */
  id: string;
  /** The organization this membership belongs to. */
  orgId: string;
  /** The user who holds this membership. */
  userId: string;
  /** The member's role within the org. */
  role: OrgMemberRole;
  /** Current membership status. */
  status: OrgMemberStatus;
  createdAt?: ISODateTime;
}

export type OrgMemberUpdateRequestRole = typeof OrgMemberUpdateRequestRole[keyof typeof OrgMemberUpdateRequestRole];


export const OrgMemberUpdateRequestRole = {
  owner: 'owner',
  admin: 'admin',
  issuer: 'issuer',
  viewer: 'viewer',
} as const;

export type OrgMemberUpdateRequestStatus = typeof OrgMemberUpdateRequestStatus[keyof typeof OrgMemberUpdateRequestStatus];


export const OrgMemberUpdateRequestStatus = {
  active: 'active',
  suspended: 'suspended',
} as const;

/**
 * Partial update for a membership record.
 */
export interface OrgMemberUpdateRequest {
  role?: OrgMemberUpdateRequestRole;
  status?: OrgMemberUpdateRequestStatus;
}

export interface PagedOrgMembers {
  meta: PagedMeta;
  data: OrgMember[];
}

export type OrgMemberDetail = OrgMember & {
  user?: User;
};

export interface PagedOrgMemberDetails {
  meta: PagedMeta;
  data: OrgMemberDetail[];
}

/**
 * An organization together with the user's membership record in it.
 */
export interface UserOrgMembership {
  org: Org;
  membership: OrgMember;
}

/**
 * Payload for creating a membership request (self-join or admin invite).
 */
export interface MembershipRequestCreate {
  /** Target user ID. If omitted, the request is for the authenticated user. */
  userId?: string;
  /**
   * Optional message from the requester.
   * @maxLength 1000
   */
  message?: string;
}

/**
 * Current request status.
 */
export type MembershipRequestStatus = typeof MembershipRequestStatus[keyof typeof MembershipRequestStatus];


export const MembershipRequestStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  canceled: 'canceled',
} as const;

/**
 * A request for a user to become a member of an organization.
 */
export interface MembershipRequest {
  /** Unique request identifier. */
  id: string;
  /** Target organization. */
  orgId: string;
  /** Requesting user. */
  userId: string;
  /** Current request status. */
  status: MembershipRequestStatus;
  /** Optional message from the requester. */
  message?: string;
  createdAt?: ISODateTime;
}

export interface PagedMembershipRequests {
  meta: PagedMeta;
  data: MembershipRequest[];
}

/**
 * A learner's global profile, independent of any organization.
 */
export interface Learner {
  /** Unique learner identifier. */
  id: string;
  /** Learner's display name. */
  name?: string;
  /** Learner's email address (may be null for externally provisioned learners). */
  email?: string;
  createdAt?: ISODateTime;
  /** URL-friendly identifier for the learner. */
  slug?: string;
  /** Learner's profile photo URL. */
  profileImageUrl?: string;
  /** Learner's profile cover image URL. */
  coverImageUrl?: string;
  /** Short biography or about text. */
  bio?: string;
  /** Job title or role. */
  title?: string;
  /** City or region. */
  location?: string;
}

/**
 * Whether this learner is active or archived in the org.
 */
export type OrgLearnerStatus = typeof OrgLearnerStatus[keyof typeof OrgLearnerStatus];


export const OrgLearnerStatus = {
  active: 'active',
  archived: 'archived',
} as const;

/**
 * A learner's affiliation with an organization, including org-specific metadata.
 */
export interface OrgLearner {
  /** Unique org-learner record identifier. */
  id: string;
  /** The organization this learner is affiliated with. */
  orgId: string;
  /** The learner's global ID. */
  learnerId: string;
  /** External reference such as a roster ID or SIS ID. */
  externalRef?: string;
  /** Whether this learner is active or archived in the org. */
  status: OrgLearnerStatus;
  createdAt?: ISODateTime;
}

/**
 * Payload for provisioning a learner in an organization.
 */
export interface OrgLearnerCreateRequest {
  /**
   * Learner's display name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** Learner's email address. */
  email?: string;
  /**
   * External roster or SIS identifier.
   * @maxLength 255
   */
  externalRef?: string;
}

/**
 * Current progress status.
 */
export type BadgeProgressStatus = typeof BadgeProgressStatus[keyof typeof BadgeProgressStatus];


export const BadgeProgressStatus = {
  not_started: 'not_started',
  in_progress: 'in_progress',
  complete: 'complete',
} as const;

/**
 * Tracks a learner's progress toward earning a badge within a specific org.
 */
export interface BadgeProgress {
  /** The org in which this progress is tracked. */
  orgId: string;
  /** The learner this progress belongs to. */
  learnerId: string;
  /** The badge being worked toward. */
  badgeId: string;
  /** Current progress status. */
  status: BadgeProgressStatus;
  /** IDs of criteria the learner has completed. */
  completedCriteriaIds?: string[];
  updatedAt?: ISODateTime;
}

/**
 * Current issuance status.
 */
export type IssuanceStatus = typeof IssuanceStatus[keyof typeof IssuanceStatus];


export const IssuanceStatus = {
  issued: 'issued',
  revoked: 'revoked',
} as const;

/**
 * Record of a badge being issued to a learner by an org.
 */
export interface Issuance {
  /** Unique issuance identifier. */
  id: string;
  /** The org that issued the badge. */
  orgId: string;
  /** The learner who received the badge. */
  learnerId: string;
  /** The badge that was issued. */
  badgeId: string;
  /** The public assertion ID for verification. */
  assertionId: string;
  /** Current issuance status. */
  status: IssuanceStatus;
  issuedAt: ISODateTime;
  /** When the issuance was revoked, if applicable. */
  revokedAt?: ISODateTime | null;
}

export type OrgLearnerDetail = OrgLearner & {
  learner?: Learner;
  /** Badge progress records for this learner within this org. */
  badgeProgress?: BadgeProgress[];
  /** Badge issuances for this learner within this org. */
  issuances?: Issuance[];
};

export interface PagedLearners {
  meta: PagedMeta;
  data: Learner[];
}

export interface PagedOrgLearners {
  meta: PagedMeta;
  data: OrgLearnerDetail[];
}

/**
 * Payload for bulk-importing learners into an organization.
 */
export interface BulkLearnerImportRequest {
  /** List of learner records to import. */
  learners: OrgLearnerCreateRequest[];
}

/**
 * Current job status.
 */
export type ImportJobStatus = typeof ImportJobStatus[keyof typeof ImportJobStatus];


export const ImportJobStatus = {
  queued: 'queued',
  running: 'running',
  complete: 'complete',
  failed: 'failed',
} as const;

/**
 * Status of an asynchronous bulk import job.
 */
export interface ImportJob {
  /** Unique job identifier. */
  id: string;
  /** Current job status. */
  status: ImportJobStatus;
  /** Total number of records in the import. */
  totalCount?: number;
  /** Number of records successfully imported so far. */
  successCount?: number;
  /** Number of records that failed to import. */
  errorCount?: number;
  createdAt?: ISODateTime;
  /** Error messages for individual failed records. */
  errors?: string[];
}

/**
 * A single criterion within a badge definition.
 */
export interface BadgeCriteriaItem {
  /** Unique criterion identifier. */
  id: string;
  /** Human-readable description of the criterion. */
  label: string;
  /** Whether this criterion is required to earn the badge. */
  isRequired?: boolean;
}

/**
 * A badge definition including its criteria. Aligned with Open Badges concepts.
 */
export interface Badge {
  /** Unique badge identifier. */
  id: string;
  /** Badge display name. */
  name: string;
  /** Detailed description of what this badge represents. */
  description?: string;
  /** URL to the badge image. */
  imageUrl?: string;
  /** List of criteria that must be met to earn this badge. */
  criteria?: BadgeCriteriaItem[];
  /** The org that created this badge. */
  createdByOrgId?: string;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * Payload for creating a badge.
 */
export interface BadgeCreateRequest {
  /**
   * Badge name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Badge description.
   * @maxLength 2000
   */
  description?: string;
  /** URL to the badge image. */
  imageUrl?: string;
  /** Initial criteria for the badge. */
  criteria?: BadgeCriteriaItem[];
  /** The org creating this badge. */
  createdByOrgId: string;
}

/**
 * Partial update for a badge definition.
 */
export interface BadgeUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
  imageUrl?: string;
  criteria?: BadgeCriteriaItem[];
}

export interface PagedBadges {
  meta: PagedMeta;
  data: Badge[];
}

export type BadgeProgressUpdateRequestStatus = typeof BadgeProgressUpdateRequestStatus[keyof typeof BadgeProgressUpdateRequestStatus];


export const BadgeProgressUpdateRequestStatus = {
  in_progress: 'in_progress',
  complete: 'complete',
} as const;

/**
 * Partial update for a learner's badge progress.
 */
export interface BadgeProgressUpdateRequest {
  status?: BadgeProgressUpdateRequestStatus;
  completedCriteriaIds?: string[];
}

/**
 * Payload for issuing a badge to a learner.
 */
export interface IssuanceCreateRequest {
  /** The learner receiving the badge. */
  learnerId: string;
  /** The badge being issued. */
  badgeId: string;
  /** Optional URL to supporting evidence. */
  evidenceUrl?: string;
}

export interface PagedIssuances {
  meta: PagedMeta;
  data: Issuance[];
}

/**
 * Public verification payload for an issued badge, aligned with Open Badges concepts.
 */
export interface Assertion {
  /** Unique assertion identifier. */
  id: string;
  /** The org that issued the badge. */
  issuerOrgId: string;
  /** The learner who earned the badge. */
  recipientLearnerId: string;
  /** The badge that was earned. */
  badgeId: string;
  issuedAt: ISODateTime;
  /** Optional URL to supporting evidence. */
  evidenceUrl?: string;
}

/**
 * A learner's full journey for a specific badge across all orgs.
 */
export interface LearnerBadgeJourney {
  /** The learner. */
  learnerId: string;
  badge: Badge;
  /** Progress records from each org tracking this badge. */
  progressByOrg?: BadgeProgress[];
  /** Assertions earned for this badge. */
  assertions?: Assertion[];
}

export interface PagedLearnerBadges {
  meta: PagedMeta;
  data: LearnerBadgeJourney[];
}

/**
 * A curated group of badges, optionally published to the public registry.
 */
export interface Collection {
  /** Unique collection identifier. */
  id: string;
  /** Collection display name. */
  name: string;
  /** Description of the collection's purpose. */
  description?: string;
  /** The org that created this collection. */
  createdByOrgId: string;
  /** Cover image URL for the collection. */
  imageUrl?: string;
  /** Total number of badges in the collection. */
  badgeCount?: number;
  /** Whether this collection is visible in the public registry. */
  published?: boolean;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * Aggregated usage statistics for a collection.
 */
export interface CollectionStats {
  /** Total badges issued across all badges in this collection. */
  totalIssuances: number;
  /** Distinct learners who earned at least one badge in this collection. */
  uniqueLearners: number;
  /** Number of badges in this collection. */
  badgeCount: number;
  /** Average percentage of learners who complete all badges (0-100). */
  averageCompletionRate?: number;
}

export type CollectionDetail = Collection & {
  /** Summary of each badge in the collection. */
  badgeSummaries?: {
  id: string;
  name: string;
  description?: string;
  imageUrl?: string;
  /** Total number of times this badge has been issued. */
  issuanceCount?: number;
}[];
  stats?: CollectionStats;
};

/**
 * Payload for creating a collection.
 */
export interface CollectionCreateRequest {
  /**
   * Collection name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Collection description.
   * @maxLength 2000
   */
  description?: string;
  /** Cover image URL for the collection. */
  imageUrl?: string;
  /** The org creating this collection. */
  createdByOrgId: string;
  /** Initial badge IDs to include in the collection. */
  badgeIds?: string[];
}

/**
 * Partial update for a collection, including adding or removing badges.
 */
export interface CollectionUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
  imageUrl?: string;
  /** Badge IDs to add to the collection. */
  addBadgeIds?: string[];
  /** Badge IDs to remove from the collection. */
  removeBadgeIds?: string[];
}

export interface PagedCollections {
  meta: PagedMeta;
  data: Collection[];
}

/**
 * Payload for requesting authorization to issue badges from a collection.
 */
export interface IssueAuthorizationRequestCreate {
  /** The org requesting issuance authorization. */
  requestingOrgId: string;
  /**
   * Optional message explaining the request.
   * @maxLength 1000
   */
  message?: string;
}

/**
 * Current request status.
 */
export type IssueAuthorizationRequestStatus = typeof IssueAuthorizationRequestStatus[keyof typeof IssueAuthorizationRequestStatus];


export const IssueAuthorizationRequestStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
} as const;

/**
 * A request from an org to be authorized to issue badges from a collection.
 */
export interface IssueAuthorizationRequest {
  /** Unique request identifier. */
  id: string;
  /** The collection being requested. */
  collectionId: string;
  /** The org requesting authorization. */
  requestingOrgId: string;
  /** Current request status. */
  status: IssueAuthorizationRequestStatus;
  /** Optional message from the requester. */
  message?: string;
  createdAt?: ISODateTime;
}

/**
 * A granted authorization for an org to issue badges from a collection.
 */
export interface IssueAuthorization {
  /** Unique authorization identifier. */
  id: string;
  /** The authorized collection. */
  collectionId: string;
  /** The authorized org. */
  orgId: string;
  grantedAt?: ISODateTime;
}

export interface PagedIssueAuthorizationRequests {
  meta: PagedMeta;
  data: IssueAuthorizationRequest[];
}

/**
 * Current cohort status.
 */
export type CohortStatus = typeof CohortStatus[keyof typeof CohortStatus];


export const CohortStatus = {
  active: 'active',
  draft: 'draft',
  archived: 'archived',
} as const;

/**
 * A named group of learners within an organization.
 */
export interface Cohort {
  /** Unique cohort identifier. */
  id: string;
  /** The org this cohort belongs to. */
  orgId: string;
  /** Cohort display name. */
  name: string;
  /** URL-safe identifier for routing. */
  slug: string;
  /** Optional description of the cohort. */
  description?: string;
  /** Current cohort status. */
  status: CohortStatus;
  /** Optional cover image URL for display. */
  coverImageUrl?: string;
  /** Member IDs of staff assigned to this cohort. */
  assignedStaffIds?: string[];
  /** Number of learners in this cohort. */
  learnerCount?: number;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

export type CohortDetail = Cohort & {
  /** Learners in this cohort. */
  learners?: Learner[];
};

/**
 * Cohort status (defaults to draft).
 */
export type CohortCreateRequestStatus = typeof CohortCreateRequestStatus[keyof typeof CohortCreateRequestStatus];


export const CohortCreateRequestStatus = {
  active: 'active',
  draft: 'draft',
  archived: 'archived',
} as const;

/**
 * Payload for creating a cohort.
 */
export interface CohortCreateRequest {
  /**
   * Cohort name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * URL-safe identifier.
   * @minLength 1
   * @maxLength 255
   */
  slug: string;
  /**
   * Optional description.
   * @maxLength 2000
   */
  description?: string;
  /** Cohort status (defaults to draft). */
  status?: CohortCreateRequestStatus;
  /** Optional cover image URL. */
  coverImageUrl?: string;
  /** Member IDs of staff to assign. */
  assignedStaffIds?: string[];
}

export type CohortUpdateRequestStatus = typeof CohortUpdateRequestStatus[keyof typeof CohortUpdateRequestStatus];


export const CohortUpdateRequestStatus = {
  active: 'active',
  draft: 'draft',
  archived: 'archived',
} as const;

/**
 * Partial update for a cohort.
 */
export interface CohortUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  slug?: string;
  /** @maxLength 2000 */
  description?: string;
  status?: CohortUpdateRequestStatus;
  coverImageUrl?: string;
  assignedStaffIds?: string[];
}

/**
 * Payload for adding learners to a cohort.
 */
export interface CohortLearnersAddRequest {
  /** List of learner IDs to add. */
  learnerIds: string[];
}

export interface PagedCohorts {
  meta: PagedMeta;
  data: Cohort[];
}

/**
 * Current program status.
 */
export type ProgramStatus = typeof ProgramStatus[keyof typeof ProgramStatus];


export const ProgramStatus = {
  draft: 'draft',
  active: 'active',
  archived: 'archived',
} as const;

/**
 * A reusable credential program template containing phases, badges, and checkpoints.
 */
export interface Program {
  /** Unique program identifier. */
  id: string;
  /** The organization that created this program. */
  orgId: string;
  /** Program display name. */
  name: string;
  /**
   * URL-friendly unique identifier for the program.
   * @pattern ^[a-z0-9]+(?:-[a-z0-9]+)*$
   */
  slug: string;
  /** Detailed program description and objectives. */
  description?: string;
  /** Cover image URL for the program. */
  imageUrl?: string;
  /** Current program status. */
  status: ProgramStatus;
  /** Total number of phases in the program. */
  phaseCount?: number;
  /** Total number of badges across all phases. */
  totalBadgeCount?: number;
  /** Total number of checkpoints across all phases. */
  totalCheckpointCount?: number;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * A badge within a program phase, including collection context for constructing badge detail links.
 */
export interface PhaseBadge {
  /** Badge identifier. */
  id: string;
  /** Badge display name. */
  name: string;
  /** Collection this badge belongs to (used to construct badge detail URLs). */
  collectionId: string;
  /** Badge image URL. */
  imageUrl?: string;
}

/**
 * A program-specific milestone that requires staff sign-off.
 */
export interface Checkpoint {
  /** Unique checkpoint identifier. */
  id: string;
  /** Checkpoint description. */
  label: string;
  /** Whether this checkpoint is required for phase completion. */
  isRequired?: boolean;
}

/**
 * A phase within a program containing badges and checkpoints.
 */
export interface Phase {
  /** Unique phase identifier. */
  id: string;
  /** Phase display name. */
  name: string;
  /** Phase description and learning objectives. */
  description?: string;
  /** Display order within the program (0-indexed). */
  order: number;
  /** Badges included in this phase, with collection context for linking. */
  badges: PhaseBadge[];
  /** Checkpoints that must be signed off in this phase. */
  checkpoints: Checkpoint[];
}

export type ProgramDetail = Program & {
  /** Ordered list of phases in this program. */
  phases?: Phase[];
};

/**
 * Initial program status.
 */
export type ProgramCreateRequestStatus = typeof ProgramCreateRequestStatus[keyof typeof ProgramCreateRequestStatus];


export const ProgramCreateRequestStatus = {
  draft: 'draft',
  active: 'active',
  archived: 'archived',
} as const;

export interface CheckpointCreateRequest {
  /**
   * @minLength 1
   * @maxLength 500
   */
  label: string;
  isRequired?: boolean;
}

/**
 * Phase definition for program creation/update.
 */
export interface PhaseCreateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** @maxLength 1000 */
  description?: string;
  /** @minimum 0 */
  order: number;
  badgeIds: string[];
  checkpoints: CheckpointCreateRequest[];
}

/**
 * Payload for creating a program.
 */
export interface ProgramCreateRequest {
  /**
   * Program name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Program description.
   * @maxLength 2000
   */
  description?: string;
  /** Cover image URL. */
  imageUrl?: string;
  /** Initial program status. */
  status?: ProgramCreateRequestStatus;
  /** Initial phases for the program. */
  phases?: PhaseCreateRequest[];
}

export type ProgramUpdateRequestStatus = typeof ProgramUpdateRequestStatus[keyof typeof ProgramUpdateRequestStatus];


export const ProgramUpdateRequestStatus = {
  draft: 'draft',
  active: 'active',
  archived: 'archived',
} as const;

/**
 * Payload for updating a program.
 */
export interface ProgramUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
  imageUrl?: string;
  status?: ProgramUpdateRequestStatus;
  phases?: PhaseCreateRequest[];
}

export interface PagedPrograms {
  meta: PagedMeta;
  data: Program[];
}

/**
 * Due date for a specific phase within an assignment.
 */
export interface PhaseDueDate {
  /** The phase this due date applies to. */
  phaseId: string;
  /** When this phase should be completed. */
  dueDate: string;
}

/**
 * A program assigned to a cohort, creating templates for learner assignments.
 */
export interface CohortProgramAssignment {
  /** Unique assignment identifier. */
  id: string;
  /** The cohort receiving the program. */
  cohortId: string;
  /** The program being assigned. */
  programId: string;
  /** User ID who created the assignment. */
  assignedBy: string;
  assignedAt: ISODateTime;
  /** Optional due dates for each phase (by phase ID). */
  phaseDueDates?: PhaseDueDate[];
}

export type CohortProgramAssignmentDetail = CohortProgramAssignment & {
  program?: ProgramDetail;
  /** Basic cohort info. */
  cohort?: {
  id: string;
  name: string;
  slug: string;
};
  /** Number of learners with this program assignment. */
  learnerAssignmentCount?: number;
};

/**
 * A program assigned to a learner, either directly or via cohort.
 */
export interface LearnerProgramAssignment {
  /** Unique assignment identifier. */
  id: string;
  /** The learner receiving the program. */
  learnerId: string;
  /** The program being assigned. */
  programId: string;
  /** If assigned via cohort, the cohort assignment ID. */
  cohortAssignmentId?: string;
  /** User ID who created the assignment. */
  assignedBy: string;
  assignedAt: ISODateTime;
  /** Due dates for each phase (inherited or custom). */
  phaseDueDates?: PhaseDueDate[];
  /** When the learner completed all requirements. */
  completedAt?: string;
}

/**
 * Progress for a single phase.
 */
export interface PhaseProgress {
  phaseId: string;
  badgesEarned: number;
  badgesTotal: number;
  checkpointsSigned: number;
  checkpointsTotal: number;
  /** Whether all requirements are met. */
  isComplete: boolean;
}

/**
 * Record of a checkpoint being signed off.
 */
export interface CheckpointCompletion {
  /** Unique completion identifier. */
  id: string;
  /** Learner assignment ID. */
  assignmentId: string;
  /** The checkpoint that was completed. */
  checkpointId: string;
  /** Staff user who signed off. */
  signedBy: string;
  signedAt: ISODateTime;
  /**
   * Optional notes about the completion.
   * @maxLength 1000
   */
  notes?: string;
}

/**
 * Learner's progress through a program.
 */
export interface ProgramProgress {
  /** Number of badges earned. */
  badgesEarned: number;
  /** Total badges in program. */
  badgesTotal: number;
  /** Number of checkpoints signed. */
  checkpointsSigned: number;
  /** Total checkpoints in program. */
  checkpointsTotal: number;
  /** Per-phase completion status. */
  phaseProgress?: PhaseProgress[];
  /** All checkpoint completions for this assignment. */
  checkpointCompletions?: CheckpointCompletion[];
}

export type LearnerProgramAssignmentDetail = LearnerProgramAssignment & {
  program?: ProgramDetail;
  /** Basic learner info. */
  learner?: {
  id: string;
  name: string;
  email?: string;
};
  progress?: ProgramProgress;
};

/**
 * Payload to assign a program to a cohort.
 */
export interface CohortProgramAssignmentCreateRequest {
  /** Program to assign. */
  programId: string;
  phaseDueDates?: PhaseDueDate[];
}

/**
 * Payload to assign a program to a learner.
 */
export interface LearnerProgramAssignmentCreateRequest {
  /** Program to assign. */
  programId: string;
  phaseDueDates?: PhaseDueDate[];
}

/**
 * Payload to sign off on a checkpoint.
 */
export interface CheckpointSignRequest {
  /**
   * Optional notes about the completion.
   * @maxLength 1000
   */
  notes?: string;
}

export interface PagedCohortProgramAssignments {
  meta: PagedMeta;
  data: CohortProgramAssignmentDetail[];
}

export interface PagedLearnerProgramAssignments {
  meta: PagedMeta;
  data: LearnerProgramAssignmentDetail[];
}

/**
 * Lightweight badge representation used in library list responses.
 */
export interface BadgeSummaryItem {
  id: string;
  name: string;
  description?: string;
  imageUrl?: string;
  issuanceCount?: number;
}

export type OrgCollectionRelStatus = typeof OrgCollectionRelStatus[keyof typeof OrgCollectionRelStatus];


export const OrgCollectionRelStatus = {
  pending: 'pending',
  active: 'active',
  archived: 'archived',
  rejected: 'rejected',
} as const;

/**
 * Whether the org created this collection or was authorized to use it.
 */
export type OrgCollectionRelSource = typeof OrgCollectionRelSource[keyof typeof OrgCollectionRelSource];


export const OrgCollectionRelSource = {
  owned: 'owned',
  authorized: 'authorized',
} as const;

/**
 * An organization's relationship to a credential collection â€” either owned or authorized.
 */
export interface OrgCollectionRel {
  id: string;
  orgId: string;
  collectionId: string;
  status: OrgCollectionRelStatus;
  /** Whether the org created this collection or was authorized to use it. */
  source: OrgCollectionRelSource;
  /** Number of programs in this org that reference this collection. */
  programCount: number;
  /** The issue authorization request that granted access (authorized source only). */
  authRequestId?: string;
  /** Internal admin notes. */
  notes?: string;
  collection: Collection;
  requestedAt?: ISODateTime;
  approvedAt?: ISODateTime;
  statusChangedAt?: ISODateTime;
}

export type OrgBadgeRelStatus = typeof OrgBadgeRelStatus[keyof typeof OrgBadgeRelStatus];


export const OrgBadgeRelStatus = {
  pending: 'pending',
  active: 'active',
  archived: 'archived',
} as const;

/**
 * An organization's relationship to a single badge within its library.
 */
export interface OrgBadgeRel {
  id: string;
  orgId: string;
  badgeId: string;
  collectionRelId: string;
  status: OrgBadgeRelStatus;
  /** Number of programs referencing this badge. */
  programCount: number;
  badge: BadgeSummaryItem;
}

export type OrgCollectionRelDetail = OrgCollectionRel & {
  badgeRels: OrgBadgeRel[];
};

export type OrgCollectionRelUpdateRequestStatus = typeof OrgCollectionRelUpdateRequestStatus[keyof typeof OrgCollectionRelUpdateRequestStatus];


export const OrgCollectionRelUpdateRequestStatus = {
  active: 'active',
  archived: 'archived',
} as const;

export interface OrgCollectionRelUpdateRequest {
  status?: OrgCollectionRelUpdateRequestStatus;
  notes?: string;
}

export interface PagedOrgCollectionRels {
  meta: PagedMeta;
  data: OrgCollectionRel[];
}

export type OrgBadgeRelDetail = OrgBadgeRel & {
  badge: Badge;
  collectionRel: OrgCollectionRel;
};

export interface PagedOrgBadgeRels {
  meta: PagedMeta;
  data: OrgBadgeRel[];
}

export type CredLibraryAnalyticsAdoptionFunnel = {
  viewedInCatalog: number;
  requested: number;
  approved: number;
  activeInLibrary: number;
  referencedInPrograms: number;
};

export type CredLibraryAnalyticsTopCollectionsItem = {
  collectionRelId: string;
  collectionName: string;
  programCount: number;
};

/**
 * Library-level adoption analytics for an organization.
 */
export interface CredLibraryAnalytics {
  adoptionFunnel: CredLibraryAnalyticsAdoptionFunnel;
  /** Active library items not yet referenced in any program. */
  unusedActiveCount: number;
  /** Average days from authorization request to approval. */
  avgTimeToApprovalDays: number;
  topCollections: CredLibraryAnalyticsTopCollectionsItem[];
}

export type CredCollectionAnalyticsProgramsItem = {
  id: string;
  name: string;
  slug: string;
};

export type CredCollectionAnalyticsBadgeAdoptionItem = {
  badgeRelId: string;
  badgeName: string;
  programCount: number;
};

/**
 * Analytics for a specific collection relationship.
 */
export interface CredCollectionAnalytics {
  collectionRelId: string;
  collection: Collection;
  programCount: number;
  programs: CredCollectionAnalyticsProgramsItem[];
  badgeAdoption: CredCollectionAnalyticsBadgeAdoptionItem[];
}

export type CredBadgeAnalyticsProgramsItem = {
  id: string;
  name: string;
  slug: string;
};

/**
 * Analytics for a specific badge relationship.
 */
export interface CredBadgeAnalytics {
  badgeRelId: string;
  badge: Badge;
  programCount: number;
  programs: CredBadgeAnalyticsProgramsItem[];
}

/**
 * Validation error
 */
export type BadRequestResponse = ErrorResponse;

/**
 * Missing or invalid authentication token
 */
export type UnauthorizedResponse = ErrorResponse;

/**
 * Insufficient permissions
 */
export type ForbiddenResponse = ErrorResponse;

/**
 * Resource not found
 */
export type NotFoundResponse = ErrorResponse;

/**
 * Page number (1-indexed).
 */
export type PageParameter = number;

/**
 * Number of items per page.
 */
export type PageSizeParameter = number;

/**
 * Keyword search.
 */
export type QueryParameter = string;

export type ListOrgsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Optional structured filter (implementation-defined).
 */
filter?: { [key: string]: unknown };
};

export type ListOrgMembersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListMembershipRequestsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListOrgLearnersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListIssuancesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Filter issuances by learner.
 */
learnerId?: string;
/**
 * Filter issuances by badge.
 */
badgeId?: string;
/**
 * Filter by issuance status.
 */
status?: ListIssuancesStatus;
};

export type ListIssuancesStatus = typeof ListIssuancesStatus[keyof typeof ListIssuancesStatus];


export const ListIssuancesStatus = {
  issued: 'issued',
  revoked: 'revoked',
} as const;

export type ListCohortsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Filter by cohort status.
 */
status?: ListCohortsStatus;
/**
 * Filter cohorts where this member is assigned.
 */
staffId?: string;
};

export type ListCohortsStatus = typeof ListCohortsStatus[keyof typeof ListCohortsStatus];


export const ListCohortsStatus = {
  active: 'active',
  draft: 'draft',
  archived: 'archived',
} as const;

export type ListProgramsParams = {
/**
 * Filter by program status.
 */
status?: ListProgramsStatus;
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListProgramsStatus = typeof ListProgramsStatus[keyof typeof ListProgramsStatus];


export const ListProgramsStatus = {
  draft: 'draft',
  active: 'active',
  archived: 'archived',
} as const;

export type ListCohortProgramAssignmentsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListLearnerProgramAssignmentsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListUsersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListUserOrgs200 = {
  data: UserOrgMembership[];
};

export type ListLearnersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListLearnerBadgesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListBadgesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Filter badges by creator org.
 */
orgId?: string;
};

export type ListCollectionsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Filter collections accessible to this org (created by or authorized for).
 */
orgId?: string;
};

export type BrowseRegistryParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListIssueAuthorizationsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListOrgCollectionRelsParams = {
status?: ListOrgCollectionRelsStatus;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListOrgCollectionRelsStatus = typeof ListOrgCollectionRelsStatus[keyof typeof ListOrgCollectionRelsStatus];


export const ListOrgCollectionRelsStatus = {
  pending: 'pending',
  active: 'active',
  archived: 'archived',
  rejected: 'rejected',
} as const;

export type ListOrgBadgeRelsParams = {
status?: ListOrgBadgeRelsStatus;
collectionRelId?: string;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListOrgBadgeRelsStatus = typeof ListOrgBadgeRelsStatus[keyof typeof ListOrgBadgeRelsStatus];


export const ListOrgBadgeRelsStatus = {
  pending: 'pending',
  active: 'active',
  archived: 'archived',
} as const;

/**
 * Creates a new user account and returns JWT tokens. Email must be unique.
 * @summary Register a user account
 */
export type registerResponse201 = {
  data: AuthResponse
  status: 201
}

export type registerResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type registerResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type registerResponseSuccess = (registerResponse201) & {
  headers: Headers;
};
export type registerResponseError = (registerResponse400 | registerResponse409) & {
  headers: Headers;
};

export type registerResponse = (registerResponseSuccess | registerResponseError)

export const getRegisterUrl = () => {


  

  return `/auth/register`
}

export const register = async (registerRequest: RegisterRequest, options?: RequestInit): Promise<registerResponse> => {
  
  const res = await fetch(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registerResponse
}



/**
 * Authenticates a user by email and password, returning JWT tokens.
 * @summary Login and receive JWT access token
 */
export type loginResponse200 = {
  data: AuthResponse
  status: 200
}

export type loginResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type loginResponseSuccess = (loginResponse200) & {
  headers: Headers;
};
export type loginResponseError = (loginResponse401) & {
  headers: Headers;
};

export type loginResponse = (loginResponseSuccess | loginResponseError)

export const getLoginUrl = () => {


  

  return `/auth/login`
}

export const login = async (loginRequest: LoginRequest, options?: RequestInit): Promise<loginResponse> => {
  
  const res = await fetch(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginResponse
}



/**
 * Exchanges a valid refresh token for a new access/refresh token pair.
 * @summary Refresh access token
 */
export type refreshTokenResponse200 = {
  data: AuthResponse
  status: 200
}

export type refreshTokenResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type refreshTokenResponseSuccess = (refreshTokenResponse200) & {
  headers: Headers;
};
export type refreshTokenResponseError = (refreshTokenResponse401) & {
  headers: Headers;
};

export type refreshTokenResponse = (refreshTokenResponseSuccess | refreshTokenResponseError)

export const getRefreshTokenUrl = () => {


  

  return `/auth/refresh`
}

export const refreshToken = async (refreshRequest: RefreshRequest, options?: RequestInit): Promise<refreshTokenResponse> => {
  
  const res = await fetch(getRefreshTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      refreshRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: refreshTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as refreshTokenResponse
}



/**
 * Invalidates the current session and refresh token.
 * @summary Logout (invalidate refresh token / session)
 */
export type logoutResponse204 = {
  data: void
  status: 204
}

export type logoutResponse401 = {
  data: UnauthorizedResponse
  status: 401
}
    
export type logoutResponseSuccess = (logoutResponse204) & {
  headers: Headers;
};
export type logoutResponseError = (logoutResponse401) & {
  headers: Headers;
};

export type logoutResponse = (logoutResponseSuccess | logoutResponseError)

export const getLogoutUrl = () => {


  

  return `/auth/logout`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  const res = await fetch(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: logoutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as logoutResponse
}



/**
 * Creates a new organization. The authenticated user becomes the owner.
 * @summary Create a new organization
 */
export type createOrgResponse201 = {
  data: Org
  status: 201
}

export type createOrgResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createOrgResponseSuccess = (createOrgResponse201) & {
  headers: Headers;
};
export type createOrgResponseError = (createOrgResponse400 | createOrgResponse401 | createOrgResponse403) & {
  headers: Headers;
};

export type createOrgResponse = (createOrgResponseSuccess | createOrgResponseError)

export const getCreateOrgUrl = () => {


  

  return `/auth/createorg`
}

export const createOrg = async (orgCreateRequest: OrgCreateRequest, options?: RequestInit): Promise<createOrgResponse> => {
  
  const res = await fetch(getCreateOrgUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createOrgResponse
}



/**
 * Super admin only. Returns a paginated list of all organizations on the platform.
 * @summary List organizations (platform-wide)
 */
export type listOrgsResponse200 = {
  data: PagedOrgs
  status: 200
}

export type listOrgsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listOrgsResponseSuccess = (listOrgsResponse200) & {
  headers: Headers;
};
export type listOrgsResponseError = (listOrgsResponse401 | listOrgsResponse403) & {
  headers: Headers;
};

export type listOrgsResponse = (listOrgsResponseSuccess | listOrgsResponseError)

export const getListOrgsUrl = (params?: ListOrgsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs?${stringifiedParams}` : `/orgs`
}

export const listOrgs = async (params?: ListOrgsParams, options?: RequestInit): Promise<listOrgsResponse> => {
  
  const res = await fetch(getListOrgsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgsResponse
}



/**
 * Returns the details of a single organization.
 * @summary Get org details
 */
export type getOrgResponse200 = {
  data: Org
  status: 200
}

export type getOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgResponseSuccess = (getOrgResponse200) & {
  headers: Headers;
};
export type getOrgResponseError = (getOrgResponse401 | getOrgResponse403 | getOrgResponse404) & {
  headers: Headers;
};

export type getOrgResponse = (getOrgResponseSuccess | getOrgResponseError)

export const getGetOrgUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}`
}

export const getOrg = async (orgId: string, options?: RequestInit): Promise<getOrgResponse> => {
  
  const res = await fetch(getGetOrgUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgResponse
}



/**
 * Partially updates an organization's profile fields.
 * @summary Update org details
 */
export type updateOrgResponse200 = {
  data: Org
  status: 200
}

export type updateOrgResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgResponseSuccess = (updateOrgResponse200) & {
  headers: Headers;
};
export type updateOrgResponseError = (updateOrgResponse400 | updateOrgResponse401 | updateOrgResponse403 | updateOrgResponse404) & {
  headers: Headers;
};

export type updateOrgResponse = (updateOrgResponseSuccess | updateOrgResponseError)

export const getUpdateOrgUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}`
}

export const updateOrg = async (orgId: string,
    orgUpdateRequest: OrgUpdateRequest, options?: RequestInit): Promise<updateOrgResponse> => {
  
  const res = await fetch(getUpdateOrgUrl(orgId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgResponse
}



/**
 * Returns the settings for an organization (join policies, default roles, etc.).
 * @summary Read org settings
 */
export type getOrgSettingsResponse200 = {
  data: OrgSettings
  status: 200
}

export type getOrgSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgSettingsResponseSuccess = (getOrgSettingsResponse200) & {
  headers: Headers;
};
export type getOrgSettingsResponseError = (getOrgSettingsResponse401 | getOrgSettingsResponse403 | getOrgSettingsResponse404) & {
  headers: Headers;
};

export type getOrgSettingsResponse = (getOrgSettingsResponseSuccess | getOrgSettingsResponseError)

export const getGetOrgSettingsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/settings`
}

export const getOrgSettings = async (orgId: string, options?: RequestInit): Promise<getOrgSettingsResponse> => {
  
  const res = await fetch(getGetOrgSettingsUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgSettingsResponse
}



/**
 * Partially updates the organization's settings.
 * @summary Update org settings
 */
export type updateOrgSettingsResponse200 = {
  data: OrgSettings
  status: 200
}

export type updateOrgSettingsResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgSettingsResponseSuccess = (updateOrgSettingsResponse200) & {
  headers: Headers;
};
export type updateOrgSettingsResponseError = (updateOrgSettingsResponse400 | updateOrgSettingsResponse401 | updateOrgSettingsResponse403 | updateOrgSettingsResponse404) & {
  headers: Headers;
};

export type updateOrgSettingsResponse = (updateOrgSettingsResponseSuccess | updateOrgSettingsResponseError)

export const getUpdateOrgSettingsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/settings`
}

export const updateOrgSettings = async (orgId: string,
    orgSettingsUpdateRequest: OrgSettingsUpdateRequest, options?: RequestInit): Promise<updateOrgSettingsResponse> => {
  
  const res = await fetch(getUpdateOrgSettingsUrl(orgId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgSettingsUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgSettingsResponse
}



/**
 * Returns aggregated statistics for the organization (member counts, badge counts, issuance counts).
 * @summary Get org statistics
 */
export type getOrgStatsResponse200 = {
  data: OrgStats
  status: 200
}

export type getOrgStatsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgStatsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgStatsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgStatsResponseSuccess = (getOrgStatsResponse200) & {
  headers: Headers;
};
export type getOrgStatsResponseError = (getOrgStatsResponse401 | getOrgStatsResponse403 | getOrgStatsResponse404) & {
  headers: Headers;
};

export type getOrgStatsResponse = (getOrgStatsResponseSuccess | getOrgStatsResponseError)

export const getGetOrgStatsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/stats`
}

export const getOrgStats = async (orgId: string, options?: RequestInit): Promise<getOrgStatsResponse> => {
  
  const res = await fetch(getGetOrgStatsUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgStatsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgStatsResponse
}



/**
 * Returns a paginated list of staff members for the organization, including nested user profiles.
 * @summary List org members (staff)
 */
export type listOrgMembersResponse200 = {
  data: PagedOrgMemberDetails
  status: 200
}

export type listOrgMembersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgMembersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listOrgMembersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listOrgMembersResponseSuccess = (listOrgMembersResponse200) & {
  headers: Headers;
};
export type listOrgMembersResponseError = (listOrgMembersResponse401 | listOrgMembersResponse403 | listOrgMembersResponse404) & {
  headers: Headers;
};

export type listOrgMembersResponse = (listOrgMembersResponseSuccess | listOrgMembersResponseError)

export const getListOrgMembersUrl = (orgId: string,
    params?: ListOrgMembersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/members?${stringifiedParams}` : `/orgs/${orgId}/members`
}

export const listOrgMembers = async (orgId: string,
    params?: ListOrgMembersParams, options?: RequestInit): Promise<listOrgMembersResponse> => {
  
  const res = await fetch(getListOrgMembersUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgMembersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgMembersResponse
}



/**
 * Returns the membership details for a specific staff member.
 * @summary Get membership record (role, status)
 */
export type getOrgMemberResponse200 = {
  data: OrgMember
  status: 200
}

export type getOrgMemberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgMemberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgMemberResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgMemberResponseSuccess = (getOrgMemberResponse200) & {
  headers: Headers;
};
export type getOrgMemberResponseError = (getOrgMemberResponse401 | getOrgMemberResponse403 | getOrgMemberResponse404) & {
  headers: Headers;
};

export type getOrgMemberResponse = (getOrgMemberResponseSuccess | getOrgMemberResponseError)

export const getGetOrgMemberUrl = (orgId: string,
    memberId: string,) => {


  

  return `/orgs/${orgId}/members/${memberId}`
}

export const getOrgMember = async (orgId: string,
    memberId: string, options?: RequestInit): Promise<getOrgMemberResponse> => {
  
  const res = await fetch(getGetOrgMemberUrl(orgId,memberId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgMemberResponse
}



/**
 * Updates a member's role or status within the organization.
 * @summary Update membership record (e.g., role/admin)
 */
export type updateOrgMemberResponse200 = {
  data: OrgMember
  status: 200
}

export type updateOrgMemberResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgMemberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgMemberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgMemberResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgMemberResponseSuccess = (updateOrgMemberResponse200) & {
  headers: Headers;
};
export type updateOrgMemberResponseError = (updateOrgMemberResponse400 | updateOrgMemberResponse401 | updateOrgMemberResponse403 | updateOrgMemberResponse404) & {
  headers: Headers;
};

export type updateOrgMemberResponse = (updateOrgMemberResponseSuccess | updateOrgMemberResponseError)

export const getUpdateOrgMemberUrl = (orgId: string,
    memberId: string,) => {


  

  return `/orgs/${orgId}/members/${memberId}`
}

export const updateOrgMember = async (orgId: string,
    memberId: string,
    orgMemberUpdateRequest: OrgMemberUpdateRequest, options?: RequestInit): Promise<updateOrgMemberResponse> => {
  
  const res = await fetch(getUpdateOrgMemberUrl(orgId,memberId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgMemberUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgMemberResponse
}



/**
 * Submits a request for a user to join an organization, or an admin invite on behalf of a user.
 * @summary Request to join org (or admin invite)
 */
export type createMembershipRequestResponse201 = {
  data: MembershipRequest
  status: 201
}

export type createMembershipRequestResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createMembershipRequestResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type createMembershipRequestResponseSuccess = (createMembershipRequestResponse201) & {
  headers: Headers;
};
export type createMembershipRequestResponseError = (createMembershipRequestResponse400 | createMembershipRequestResponse401 | createMembershipRequestResponse403 | createMembershipRequestResponse409) & {
  headers: Headers;
};

export type createMembershipRequestResponse = (createMembershipRequestResponseSuccess | createMembershipRequestResponseError)

export const getCreateMembershipRequestUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/membership-requests`
}

export const createMembershipRequest = async (orgId: string,
    membershipRequestCreate: MembershipRequestCreate, options?: RequestInit): Promise<createMembershipRequestResponse> => {
  
  const res = await fetch(getCreateMembershipRequestUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      membershipRequestCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createMembershipRequestResponse
}



/**
 * Returns pending, approved, and rejected membership requests for admin review.
 * @summary List membership requests for org (admin review)
 */
export type listMembershipRequestsResponse200 = {
  data: PagedMembershipRequests
  status: 200
}

export type listMembershipRequestsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listMembershipRequestsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listMembershipRequestsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listMembershipRequestsResponseSuccess = (listMembershipRequestsResponse200) & {
  headers: Headers;
};
export type listMembershipRequestsResponseError = (listMembershipRequestsResponse401 | listMembershipRequestsResponse403 | listMembershipRequestsResponse404) & {
  headers: Headers;
};

export type listMembershipRequestsResponse = (listMembershipRequestsResponseSuccess | listMembershipRequestsResponseError)

export const getListMembershipRequestsUrl = (orgId: string,
    params?: ListMembershipRequestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/membership-requests?${stringifiedParams}` : `/orgs/${orgId}/membership-requests`
}

export const listMembershipRequests = async (orgId: string,
    params?: ListMembershipRequestsParams, options?: RequestInit): Promise<listMembershipRequestsResponse> => {
  
  const res = await fetch(getListMembershipRequestsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listMembershipRequestsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listMembershipRequestsResponse
}



/**
 * Approves a pending membership request, creating the org member record.
 * @summary Approve membership request
 */
export type approveMembershipRequestResponse200 = {
  data: OrgMember
  status: 200
}

export type approveMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type approveMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type approveMembershipRequestResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type approveMembershipRequestResponseSuccess = (approveMembershipRequestResponse200) & {
  headers: Headers;
};
export type approveMembershipRequestResponseError = (approveMembershipRequestResponse401 | approveMembershipRequestResponse403 | approveMembershipRequestResponse404) & {
  headers: Headers;
};

export type approveMembershipRequestResponse = (approveMembershipRequestResponseSuccess | approveMembershipRequestResponseError)

export const getApproveMembershipRequestUrl = (orgId: string,
    requestId: string,) => {


  

  return `/orgs/${orgId}/membership-requests/${requestId}/approve`
}

export const approveMembershipRequest = async (orgId: string,
    requestId: string, options?: RequestInit): Promise<approveMembershipRequestResponse> => {
  
  const res = await fetch(getApproveMembershipRequestUrl(orgId,requestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: approveMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as approveMembershipRequestResponse
}



/**
 * Rejects a pending membership request.
 * @summary Reject membership request
 */
export type rejectMembershipRequestResponse204 = {
  data: void
  status: 204
}

export type rejectMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type rejectMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type rejectMembershipRequestResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type rejectMembershipRequestResponseSuccess = (rejectMembershipRequestResponse204) & {
  headers: Headers;
};
export type rejectMembershipRequestResponseError = (rejectMembershipRequestResponse401 | rejectMembershipRequestResponse403 | rejectMembershipRequestResponse404) & {
  headers: Headers;
};

export type rejectMembershipRequestResponse = (rejectMembershipRequestResponseSuccess | rejectMembershipRequestResponseError)

export const getRejectMembershipRequestUrl = (orgId: string,
    requestId: string,) => {


  

  return `/orgs/${orgId}/membership-requests/${requestId}/reject`
}

export const rejectMembershipRequest = async (orgId: string,
    requestId: string, options?: RequestInit): Promise<rejectMembershipRequestResponse> => {
  
  const res = await fetch(getRejectMembershipRequestUrl(orgId,requestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rejectMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rejectMembershipRequestResponse
}



/**
 * Returns a paginated list of learners provisioned in this organization.
 * @summary List learners affiliated with org
 */
export type listOrgLearnersResponse200 = {
  data: PagedOrgLearners
  status: 200
}

export type listOrgLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listOrgLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listOrgLearnersResponseSuccess = (listOrgLearnersResponse200) & {
  headers: Headers;
};
export type listOrgLearnersResponseError = (listOrgLearnersResponse401 | listOrgLearnersResponse403 | listOrgLearnersResponse404) & {
  headers: Headers;
};

export type listOrgLearnersResponse = (listOrgLearnersResponseSuccess | listOrgLearnersResponseError)

export const getListOrgLearnersUrl = (orgId: string,
    params?: ListOrgLearnersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/learners?${stringifiedParams}` : `/orgs/${orgId}/learners`
}

export const listOrgLearners = async (orgId: string,
    params?: ListOrgLearnersParams, options?: RequestInit): Promise<listOrgLearnersResponse> => {
  
  const res = await fetch(getListOrgLearnersUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgLearnersResponse
}



/**
 * Creates a new learner record affiliated with this organization.
 * @summary Provision a learner in this org
 */
export type createOrgLearnerResponse201 = {
  data: OrgLearner
  status: 201
}

export type createOrgLearnerResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createOrgLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createOrgLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createOrgLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createOrgLearnerResponseSuccess = (createOrgLearnerResponse201) & {
  headers: Headers;
};
export type createOrgLearnerResponseError = (createOrgLearnerResponse400 | createOrgLearnerResponse401 | createOrgLearnerResponse403 | createOrgLearnerResponse404) & {
  headers: Headers;
};

export type createOrgLearnerResponse = (createOrgLearnerResponseSuccess | createOrgLearnerResponseError)

export const getCreateOrgLearnerUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/learners`
}

export const createOrgLearner = async (orgId: string,
    orgLearnerCreateRequest: OrgLearnerCreateRequest, options?: RequestInit): Promise<createOrgLearnerResponse> => {
  
  const res = await fetch(getCreateOrgLearnerUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgLearnerCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createOrgLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createOrgLearnerResponse
}



/**
 * Accepts a batch of learner records and queues them for import.
 * @summary Bulk import learners for org
 */
export type bulkImportOrgLearnersResponse202 = {
  data: ImportJob
  status: 202
}

export type bulkImportOrgLearnersResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type bulkImportOrgLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type bulkImportOrgLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type bulkImportOrgLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type bulkImportOrgLearnersResponseSuccess = (bulkImportOrgLearnersResponse202) & {
  headers: Headers;
};
export type bulkImportOrgLearnersResponseError = (bulkImportOrgLearnersResponse400 | bulkImportOrgLearnersResponse401 | bulkImportOrgLearnersResponse403 | bulkImportOrgLearnersResponse404) & {
  headers: Headers;
};

export type bulkImportOrgLearnersResponse = (bulkImportOrgLearnersResponseSuccess | bulkImportOrgLearnersResponseError)

export const getBulkImportOrgLearnersUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/learners:bulk-import`
}

export const bulkImportOrgLearners = async (orgId: string,
    bulkLearnerImportRequest: BulkLearnerImportRequest, options?: RequestInit): Promise<bulkImportOrgLearnersResponse> => {
  
  const res = await fetch(getBulkImportOrgLearnersUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkLearnerImportRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: bulkImportOrgLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as bulkImportOrgLearnersResponse
}



/**
 * Returns learner details including badge progress and issuances scoped to this organization.
 * @summary Get learner details as it pertains to this org
 */
export type getOrgLearnerResponse200 = {
  data: OrgLearnerDetail
  status: 200
}

export type getOrgLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgLearnerResponseSuccess = (getOrgLearnerResponse200) & {
  headers: Headers;
};
export type getOrgLearnerResponseError = (getOrgLearnerResponse401 | getOrgLearnerResponse403 | getOrgLearnerResponse404) & {
  headers: Headers;
};

export type getOrgLearnerResponse = (getOrgLearnerResponseSuccess | getOrgLearnerResponseError)

export const getGetOrgLearnerUrl = (orgId: string,
    learnerId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}`
}

export const getOrgLearner = async (orgId: string,
    learnerId: string, options?: RequestInit): Promise<getOrgLearnerResponse> => {
  
  const res = await fetch(getGetOrgLearnerUrl(orgId,learnerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgLearnerResponse
}



/**
 * Returns the learner's progress on a specific badge within this organization.
 * @summary Get learner progress toward badge (org-scoped)
 */
export type getOrgLearnerBadgeProgressResponse200 = {
  data: BadgeProgress
  status: 200
}

export type getOrgLearnerBadgeProgressResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgLearnerBadgeProgressResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgLearnerBadgeProgressResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgLearnerBadgeProgressResponseSuccess = (getOrgLearnerBadgeProgressResponse200) & {
  headers: Headers;
};
export type getOrgLearnerBadgeProgressResponseError = (getOrgLearnerBadgeProgressResponse401 | getOrgLearnerBadgeProgressResponse403 | getOrgLearnerBadgeProgressResponse404) & {
  headers: Headers;
};

export type getOrgLearnerBadgeProgressResponse = (getOrgLearnerBadgeProgressResponseSuccess | getOrgLearnerBadgeProgressResponseError)

export const getGetOrgLearnerBadgeProgressUrl = (orgId: string,
    learnerId: string,
    badgeId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/badges/${badgeId}`
}

export const getOrgLearnerBadgeProgress = async (orgId: string,
    learnerId: string,
    badgeId: string, options?: RequestInit): Promise<getOrgLearnerBadgeProgressResponse> => {
  
  const res = await fetch(getGetOrgLearnerBadgeProgressUrl(orgId,learnerId,badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgLearnerBadgeProgressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgLearnerBadgeProgressResponse
}



/**
 * Updates the learner's progress on a badge, such as marking criteria complete.
 * @summary Update learner progress toward badge (org-scoped)
 */
export type updateOrgLearnerBadgeProgressResponse200 = {
  data: BadgeProgress
  status: 200
}

export type updateOrgLearnerBadgeProgressResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgLearnerBadgeProgressResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgLearnerBadgeProgressResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgLearnerBadgeProgressResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgLearnerBadgeProgressResponseSuccess = (updateOrgLearnerBadgeProgressResponse200) & {
  headers: Headers;
};
export type updateOrgLearnerBadgeProgressResponseError = (updateOrgLearnerBadgeProgressResponse400 | updateOrgLearnerBadgeProgressResponse401 | updateOrgLearnerBadgeProgressResponse403 | updateOrgLearnerBadgeProgressResponse404) & {
  headers: Headers;
};

export type updateOrgLearnerBadgeProgressResponse = (updateOrgLearnerBadgeProgressResponseSuccess | updateOrgLearnerBadgeProgressResponseError)

export const getUpdateOrgLearnerBadgeProgressUrl = (orgId: string,
    learnerId: string,
    badgeId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/badges/${badgeId}`
}

export const updateOrgLearnerBadgeProgress = async (orgId: string,
    learnerId: string,
    badgeId: string,
    badgeProgressUpdateRequest: BadgeProgressUpdateRequest, options?: RequestInit): Promise<updateOrgLearnerBadgeProgressResponse> => {
  
  const res = await fetch(getUpdateOrgLearnerBadgeProgressUrl(orgId,learnerId,badgeId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeProgressUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgLearnerBadgeProgressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgLearnerBadgeProgressResponse
}



/**
 * Issues a badge to a learner, creating a verifiable assertion record.
 * @summary Issue a badge to a learner (creates Assertion)
 */
export type createIssuanceResponse201 = {
  data: Issuance
  status: 201
}

export type createIssuanceResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createIssuanceResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createIssuanceResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createIssuanceResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createIssuanceResponseSuccess = (createIssuanceResponse201) & {
  headers: Headers;
};
export type createIssuanceResponseError = (createIssuanceResponse400 | createIssuanceResponse401 | createIssuanceResponse403 | createIssuanceResponse404) & {
  headers: Headers;
};

export type createIssuanceResponse = (createIssuanceResponseSuccess | createIssuanceResponseError)

export const getCreateIssuanceUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/issuances`
}

export const createIssuance = async (orgId: string,
    issuanceCreateRequest: IssuanceCreateRequest, options?: RequestInit): Promise<createIssuanceResponse> => {
  
  const res = await fetch(getCreateIssuanceUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      issuanceCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createIssuanceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createIssuanceResponse
}



/**
 * Returns a paginated list of badge issuances for this organization, with optional filters.
 * @summary List issuances for org
 */
export type listIssuancesResponse200 = {
  data: PagedIssuances
  status: 200
}

export type listIssuancesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listIssuancesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listIssuancesResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listIssuancesResponseSuccess = (listIssuancesResponse200) & {
  headers: Headers;
};
export type listIssuancesResponseError = (listIssuancesResponse401 | listIssuancesResponse403 | listIssuancesResponse404) & {
  headers: Headers;
};

export type listIssuancesResponse = (listIssuancesResponseSuccess | listIssuancesResponseError)

export const getListIssuancesUrl = (orgId: string,
    params?: ListIssuancesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/issuances?${stringifiedParams}` : `/orgs/${orgId}/issuances`
}

export const listIssuances = async (orgId: string,
    params?: ListIssuancesParams, options?: RequestInit): Promise<listIssuancesResponse> => {
  
  const res = await fetch(getListIssuancesUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listIssuancesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listIssuancesResponse
}



/**
 * Returns a paginated list of cohorts for this organization.
 * @summary List cohorts
 */
export type listCohortsResponse200 = {
  data: PagedCohorts
  status: 200
}

export type listCohortsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listCohortsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listCohortsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listCohortsResponseSuccess = (listCohortsResponse200) & {
  headers: Headers;
};
export type listCohortsResponseError = (listCohortsResponse401 | listCohortsResponse403 | listCohortsResponse404) & {
  headers: Headers;
};

export type listCohortsResponse = (listCohortsResponseSuccess | listCohortsResponseError)

export const getListCohortsUrl = (orgId: string,
    params?: ListCohortsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/cohorts?${stringifiedParams}` : `/orgs/${orgId}/cohorts`
}

export const listCohorts = async (orgId: string,
    params?: ListCohortsParams, options?: RequestInit): Promise<listCohortsResponse> => {
  
  const res = await fetch(getListCohortsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCohortsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCohortsResponse
}



/**
 * Creates a new learner cohort within the organization.
 * @summary Create cohort
 */
export type createCohortResponse201 = {
  data: Cohort
  status: 201
}

export type createCohortResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createCohortResponseSuccess = (createCohortResponse201) & {
  headers: Headers;
};
export type createCohortResponseError = (createCohortResponse400 | createCohortResponse401 | createCohortResponse403 | createCohortResponse404) & {
  headers: Headers;
};

export type createCohortResponse = (createCohortResponseSuccess | createCohortResponseError)

export const getCreateCohortUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/cohorts`
}

export const createCohort = async (orgId: string,
    cohortCreateRequest: CohortCreateRequest, options?: RequestInit): Promise<createCohortResponse> => {
  
  const res = await fetch(getCreateCohortUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCohortResponse
}



/**
 * Returns full cohort details including the list of learners in this cohort.
 * @summary Get cohort details (including learner constituents)
 */
export type getCohortResponse200 = {
  data: CohortDetail
  status: 200
}

export type getCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getCohortResponseSuccess = (getCohortResponse200) & {
  headers: Headers;
};
export type getCohortResponseError = (getCohortResponse401 | getCohortResponse403 | getCohortResponse404) & {
  headers: Headers;
};

export type getCohortResponse = (getCohortResponseSuccess | getCohortResponseError)

export const getGetCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const getCohort = async (orgId: string,
    cohortId: string, options?: RequestInit): Promise<getCohortResponse> => {
  
  const res = await fetch(getGetCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCohortResponse
}



/**
 * Partially updates a cohort's name or description.
 * @summary Update cohort
 */
export type updateCohortResponse200 = {
  data: Cohort
  status: 200
}

export type updateCohortResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateCohortResponseSuccess = (updateCohortResponse200) & {
  headers: Headers;
};
export type updateCohortResponseError = (updateCohortResponse400 | updateCohortResponse401 | updateCohortResponse403 | updateCohortResponse404) & {
  headers: Headers;
};

export type updateCohortResponse = (updateCohortResponseSuccess | updateCohortResponseError)

export const getUpdateCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const updateCohort = async (orgId: string,
    cohortId: string,
    cohortUpdateRequest: CohortUpdateRequest, options?: RequestInit): Promise<updateCohortResponse> => {
  
  const res = await fetch(getUpdateCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCohortResponse
}



/**
 * Permanently deletes a cohort. Learners are not removed from the organization.
 * @summary Delete cohort
 */
export type deleteCohortResponse204 = {
  data: void
  status: 204
}

export type deleteCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteCohortResponseSuccess = (deleteCohortResponse204) & {
  headers: Headers;
};
export type deleteCohortResponseError = (deleteCohortResponse401 | deleteCohortResponse403 | deleteCohortResponse404) & {
  headers: Headers;
};

export type deleteCohortResponse = (deleteCohortResponseSuccess | deleteCohortResponseError)

export const getDeleteCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const deleteCohort = async (orgId: string,
    cohortId: string, options?: RequestInit): Promise<deleteCohortResponse> => {
  
  const res = await fetch(getDeleteCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCohortResponse
}



/**
 * Adds one or more learners to a cohort by their IDs.
 * @summary Add learners to cohort (batch)
 */
export type addCohortLearnersResponse200 = {
  data: CohortDetail
  status: 200
}

export type addCohortLearnersResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type addCohortLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type addCohortLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type addCohortLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type addCohortLearnersResponseSuccess = (addCohortLearnersResponse200) & {
  headers: Headers;
};
export type addCohortLearnersResponseError = (addCohortLearnersResponse400 | addCohortLearnersResponse401 | addCohortLearnersResponse403 | addCohortLearnersResponse404) & {
  headers: Headers;
};

export type addCohortLearnersResponse = (addCohortLearnersResponseSuccess | addCohortLearnersResponseError)

export const getAddCohortLearnersUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/learners`
}

export const addCohortLearners = async (orgId: string,
    cohortId: string,
    cohortLearnersAddRequest: CohortLearnersAddRequest, options?: RequestInit): Promise<addCohortLearnersResponse> => {
  
  const res = await fetch(getAddCohortLearnersUrl(orgId,cohortId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortLearnersAddRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addCohortLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addCohortLearnersResponse
}



/**
 * Removes a single learner from a cohort.
 * @summary Remove learner from cohort
 */
export type removeCohortLearnerResponse204 = {
  data: void
  status: 204
}

export type removeCohortLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type removeCohortLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type removeCohortLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type removeCohortLearnerResponseSuccess = (removeCohortLearnerResponse204) & {
  headers: Headers;
};
export type removeCohortLearnerResponseError = (removeCohortLearnerResponse401 | removeCohortLearnerResponse403 | removeCohortLearnerResponse404) & {
  headers: Headers;
};

export type removeCohortLearnerResponse = (removeCohortLearnerResponseSuccess | removeCohortLearnerResponseError)

export const getRemoveCohortLearnerUrl = (orgId: string,
    cohortId: string,
    learnerId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/learners/${learnerId}`
}

export const removeCohortLearner = async (orgId: string,
    cohortId: string,
    learnerId: string, options?: RequestInit): Promise<removeCohortLearnerResponse> => {
  
  const res = await fetch(getRemoveCohortLearnerUrl(orgId,cohortId,learnerId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeCohortLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeCohortLearnerResponse
}



/**
 * Returns programs filtered by status.
 * @summary List programs for an organization
 */
export type listProgramsResponse200 = {
  data: PagedPrograms
  status: 200
}

export type listProgramsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listProgramsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listProgramsResponseSuccess = (listProgramsResponse200) & {
  headers: Headers;
};
export type listProgramsResponseError = (listProgramsResponse401 | listProgramsResponse403) & {
  headers: Headers;
};

export type listProgramsResponse = (listProgramsResponseSuccess | listProgramsResponseError)

export const getListProgramsUrl = (orgId: string,
    params?: ListProgramsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/programs?${stringifiedParams}` : `/orgs/${orgId}/programs`
}

export const listPrograms = async (orgId: string,
    params?: ListProgramsParams, options?: RequestInit): Promise<listProgramsResponse> => {
  
  const res = await fetch(getListProgramsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listProgramsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listProgramsResponse
}



/**
 * Creates a program template with phases.
 * @summary Create a new program
 */
export type createProgramResponse201 = {
  data: ProgramDetail
  status: 201
}

export type createProgramResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createProgramResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createProgramResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createProgramResponseSuccess = (createProgramResponse201) & {
  headers: Headers;
};
export type createProgramResponseError = (createProgramResponse400 | createProgramResponse401 | createProgramResponse403) & {
  headers: Headers;
};

export type createProgramResponse = (createProgramResponseSuccess | createProgramResponseError)

export const getCreateProgramUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/programs`
}

export const createProgram = async (orgId: string,
    programCreateRequest: ProgramCreateRequest, options?: RequestInit): Promise<createProgramResponse> => {
  
  const res = await fetch(getCreateProgramUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      programCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createProgramResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createProgramResponse
}



/**
 * Returns program with full phase details.
 * @summary Get program details
 */
export type getProgramResponse200 = {
  data: ProgramDetail
  status: 200
}

export type getProgramResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getProgramResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getProgramResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getProgramResponseSuccess = (getProgramResponse200) & {
  headers: Headers;
};
export type getProgramResponseError = (getProgramResponse401 | getProgramResponse403 | getProgramResponse404) & {
  headers: Headers;
};

export type getProgramResponse = (getProgramResponseSuccess | getProgramResponseError)

export const getGetProgramUrl = (orgId: string,
    programSlug: string,) => {


  

  return `/orgs/${orgId}/programs/${programSlug}`
}

export const getProgram = async (orgId: string,
    programSlug: string, options?: RequestInit): Promise<getProgramResponse> => {
  
  const res = await fetch(getGetProgramUrl(orgId,programSlug),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getProgramResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getProgramResponse
}



/**
 * Partially updates program details and/or phases.
 * @summary Update program
 */
export type updateProgramResponse200 = {
  data: ProgramDetail
  status: 200
}

export type updateProgramResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateProgramResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateProgramResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateProgramResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateProgramResponseSuccess = (updateProgramResponse200) & {
  headers: Headers;
};
export type updateProgramResponseError = (updateProgramResponse400 | updateProgramResponse401 | updateProgramResponse403 | updateProgramResponse404) & {
  headers: Headers;
};

export type updateProgramResponse = (updateProgramResponseSuccess | updateProgramResponseError)

export const getUpdateProgramUrl = (orgId: string,
    programSlug: string,) => {


  

  return `/orgs/${orgId}/programs/${programSlug}`
}

export const updateProgram = async (orgId: string,
    programSlug: string,
    programUpdateRequest: ProgramUpdateRequest, options?: RequestInit): Promise<updateProgramResponse> => {
  
  const res = await fetch(getUpdateProgramUrl(orgId,programSlug),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      programUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateProgramResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateProgramResponse
}



/**
 * Deletes a program if it has no active assignments.
 * @summary Delete program
 */
export type deleteProgramResponse204 = {
  data: void
  status: 204
}

export type deleteProgramResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteProgramResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteProgramResponse404 = {
  data: NotFoundResponse
  status: 404
}

export type deleteProgramResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type deleteProgramResponseSuccess = (deleteProgramResponse204) & {
  headers: Headers;
};
export type deleteProgramResponseError = (deleteProgramResponse401 | deleteProgramResponse403 | deleteProgramResponse404 | deleteProgramResponse409) & {
  headers: Headers;
};

export type deleteProgramResponse = (deleteProgramResponseSuccess | deleteProgramResponseError)

export const getDeleteProgramUrl = (orgId: string,
    programSlug: string,) => {


  

  return `/orgs/${orgId}/programs/${programSlug}`
}

export const deleteProgram = async (orgId: string,
    programSlug: string, options?: RequestInit): Promise<deleteProgramResponse> => {
  
  const res = await fetch(getDeleteProgramUrl(orgId,programSlug),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteProgramResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteProgramResponse
}



/**
 * Returns all programs assigned to a cohort.
 * @summary List program assignments for a cohort
 */
export type listCohortProgramAssignmentsResponse200 = {
  data: PagedCohortProgramAssignments
  status: 200
}

export type listCohortProgramAssignmentsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listCohortProgramAssignmentsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listCohortProgramAssignmentsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listCohortProgramAssignmentsResponseSuccess = (listCohortProgramAssignmentsResponse200) & {
  headers: Headers;
};
export type listCohortProgramAssignmentsResponseError = (listCohortProgramAssignmentsResponse401 | listCohortProgramAssignmentsResponse403 | listCohortProgramAssignmentsResponse404) & {
  headers: Headers;
};

export type listCohortProgramAssignmentsResponse = (listCohortProgramAssignmentsResponseSuccess | listCohortProgramAssignmentsResponseError)

export const getListCohortProgramAssignmentsUrl = (orgId: string,
    cohortId: string,
    params?: ListCohortProgramAssignmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/cohorts/${cohortId}/program-assignments?${stringifiedParams}` : `/orgs/${orgId}/cohorts/${cohortId}/program-assignments`
}

export const listCohortProgramAssignments = async (orgId: string,
    cohortId: string,
    params?: ListCohortProgramAssignmentsParams, options?: RequestInit): Promise<listCohortProgramAssignmentsResponse> => {
  
  const res = await fetch(getListCohortProgramAssignmentsUrl(orgId,cohortId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCohortProgramAssignmentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCohortProgramAssignmentsResponse
}



/**
 * Assigns a program to a cohort, auto-creating learner assignments.
 * @summary Assign program to cohort
 */
export type assignProgramToCohortResponse201 = {
  data: CohortProgramAssignmentDetail
  status: 201
}

export type assignProgramToCohortResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type assignProgramToCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type assignProgramToCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type assignProgramToCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type assignProgramToCohortResponseSuccess = (assignProgramToCohortResponse201) & {
  headers: Headers;
};
export type assignProgramToCohortResponseError = (assignProgramToCohortResponse400 | assignProgramToCohortResponse401 | assignProgramToCohortResponse403 | assignProgramToCohortResponse404) & {
  headers: Headers;
};

export type assignProgramToCohortResponse = (assignProgramToCohortResponseSuccess | assignProgramToCohortResponseError)

export const getAssignProgramToCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/program-assignments`
}

export const assignProgramToCohort = async (orgId: string,
    cohortId: string,
    cohortProgramAssignmentCreateRequest: CohortProgramAssignmentCreateRequest, options?: RequestInit): Promise<assignProgramToCohortResponse> => {
  
  const res = await fetch(getAssignProgramToCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortProgramAssignmentCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: assignProgramToCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as assignProgramToCohortResponse
}



/**
 * Returns assignment with aggregate progress.
 * @summary Get cohort program assignment details
 */
export type getCohortProgramAssignmentResponse200 = {
  data: CohortProgramAssignmentDetail
  status: 200
}

export type getCohortProgramAssignmentResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getCohortProgramAssignmentResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getCohortProgramAssignmentResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getCohortProgramAssignmentResponseSuccess = (getCohortProgramAssignmentResponse200) & {
  headers: Headers;
};
export type getCohortProgramAssignmentResponseError = (getCohortProgramAssignmentResponse401 | getCohortProgramAssignmentResponse403 | getCohortProgramAssignmentResponse404) & {
  headers: Headers;
};

export type getCohortProgramAssignmentResponse = (getCohortProgramAssignmentResponseSuccess | getCohortProgramAssignmentResponseError)

export const getGetCohortProgramAssignmentUrl = (orgId: string,
    cohortId: string,
    cohortAssignmentId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/program-assignments/${cohortAssignmentId}`
}

export const getCohortProgramAssignment = async (orgId: string,
    cohortId: string,
    cohortAssignmentId: string, options?: RequestInit): Promise<getCohortProgramAssignmentResponse> => {
  
  const res = await fetch(getGetCohortProgramAssignmentUrl(orgId,cohortId,cohortAssignmentId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCohortProgramAssignmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCohortProgramAssignmentResponse
}



/**
 * Removes assignment and all derived learner assignments.
 * @summary Remove program assignment from cohort
 */
export type unassignProgramFromCohortResponse204 = {
  data: void
  status: 204
}

export type unassignProgramFromCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type unassignProgramFromCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type unassignProgramFromCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type unassignProgramFromCohortResponseSuccess = (unassignProgramFromCohortResponse204) & {
  headers: Headers;
};
export type unassignProgramFromCohortResponseError = (unassignProgramFromCohortResponse401 | unassignProgramFromCohortResponse403 | unassignProgramFromCohortResponse404) & {
  headers: Headers;
};

export type unassignProgramFromCohortResponse = (unassignProgramFromCohortResponseSuccess | unassignProgramFromCohortResponseError)

export const getUnassignProgramFromCohortUrl = (orgId: string,
    cohortId: string,
    cohortAssignmentId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/program-assignments/${cohortAssignmentId}`
}

export const unassignProgramFromCohort = async (orgId: string,
    cohortId: string,
    cohortAssignmentId: string, options?: RequestInit): Promise<unassignProgramFromCohortResponse> => {
  
  const res = await fetch(getUnassignProgramFromCohortUrl(orgId,cohortId,cohortAssignmentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unassignProgramFromCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unassignProgramFromCohortResponse
}



/**
 * Returns all programs assigned to a learner.
 * @summary List program assignments for a learner
 */
export type listLearnerProgramAssignmentsResponse200 = {
  data: PagedLearnerProgramAssignments
  status: 200
}

export type listLearnerProgramAssignmentsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listLearnerProgramAssignmentsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listLearnerProgramAssignmentsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listLearnerProgramAssignmentsResponseSuccess = (listLearnerProgramAssignmentsResponse200) & {
  headers: Headers;
};
export type listLearnerProgramAssignmentsResponseError = (listLearnerProgramAssignmentsResponse401 | listLearnerProgramAssignmentsResponse403 | listLearnerProgramAssignmentsResponse404) & {
  headers: Headers;
};

export type listLearnerProgramAssignmentsResponse = (listLearnerProgramAssignmentsResponseSuccess | listLearnerProgramAssignmentsResponseError)

export const getListLearnerProgramAssignmentsUrl = (orgId: string,
    learnerId: string,
    params?: ListLearnerProgramAssignmentsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/learners/${learnerId}/program-assignments?${stringifiedParams}` : `/orgs/${orgId}/learners/${learnerId}/program-assignments`
}

export const listLearnerProgramAssignments = async (orgId: string,
    learnerId: string,
    params?: ListLearnerProgramAssignmentsParams, options?: RequestInit): Promise<listLearnerProgramAssignmentsResponse> => {
  
  const res = await fetch(getListLearnerProgramAssignmentsUrl(orgId,learnerId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listLearnerProgramAssignmentsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listLearnerProgramAssignmentsResponse
}



/**
 * Directly assigns a program to a learner.
 * @summary Assign program to learner
 */
export type assignProgramToLearnerResponse201 = {
  data: LearnerProgramAssignmentDetail
  status: 201
}

export type assignProgramToLearnerResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type assignProgramToLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type assignProgramToLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type assignProgramToLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type assignProgramToLearnerResponseSuccess = (assignProgramToLearnerResponse201) & {
  headers: Headers;
};
export type assignProgramToLearnerResponseError = (assignProgramToLearnerResponse400 | assignProgramToLearnerResponse401 | assignProgramToLearnerResponse403 | assignProgramToLearnerResponse404) & {
  headers: Headers;
};

export type assignProgramToLearnerResponse = (assignProgramToLearnerResponseSuccess | assignProgramToLearnerResponseError)

export const getAssignProgramToLearnerUrl = (orgId: string,
    learnerId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/program-assignments`
}

export const assignProgramToLearner = async (orgId: string,
    learnerId: string,
    learnerProgramAssignmentCreateRequest: LearnerProgramAssignmentCreateRequest, options?: RequestInit): Promise<assignProgramToLearnerResponse> => {
  
  const res = await fetch(getAssignProgramToLearnerUrl(orgId,learnerId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      learnerProgramAssignmentCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: assignProgramToLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as assignProgramToLearnerResponse
}



/**
 * Returns assignment with full progress tracking.
 * @summary Get learner program assignment details
 */
export type getLearnerProgramAssignmentResponse200 = {
  data: LearnerProgramAssignmentDetail
  status: 200
}

export type getLearnerProgramAssignmentResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getLearnerProgramAssignmentResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getLearnerProgramAssignmentResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getLearnerProgramAssignmentResponseSuccess = (getLearnerProgramAssignmentResponse200) & {
  headers: Headers;
};
export type getLearnerProgramAssignmentResponseError = (getLearnerProgramAssignmentResponse401 | getLearnerProgramAssignmentResponse403 | getLearnerProgramAssignmentResponse404) & {
  headers: Headers;
};

export type getLearnerProgramAssignmentResponse = (getLearnerProgramAssignmentResponseSuccess | getLearnerProgramAssignmentResponseError)

export const getGetLearnerProgramAssignmentUrl = (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/program-assignments/${learnerAssignmentId}`
}

export const getLearnerProgramAssignment = async (orgId: string,
    learnerId: string,
    learnerAssignmentId: string, options?: RequestInit): Promise<getLearnerProgramAssignmentResponse> => {
  
  const res = await fetch(getGetLearnerProgramAssignmentUrl(orgId,learnerId,learnerAssignmentId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLearnerProgramAssignmentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLearnerProgramAssignmentResponse
}



/**
 * Removes assignment (only if not cohort-derived).
 * @summary Remove program assignment from learner
 */
export type unassignProgramFromLearnerResponse204 = {
  data: void
  status: 204
}

export type unassignProgramFromLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type unassignProgramFromLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type unassignProgramFromLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}

export type unassignProgramFromLearnerResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type unassignProgramFromLearnerResponseSuccess = (unassignProgramFromLearnerResponse204) & {
  headers: Headers;
};
export type unassignProgramFromLearnerResponseError = (unassignProgramFromLearnerResponse401 | unassignProgramFromLearnerResponse403 | unassignProgramFromLearnerResponse404 | unassignProgramFromLearnerResponse409) & {
  headers: Headers;
};

export type unassignProgramFromLearnerResponse = (unassignProgramFromLearnerResponseSuccess | unassignProgramFromLearnerResponseError)

export const getUnassignProgramFromLearnerUrl = (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/program-assignments/${learnerAssignmentId}`
}

export const unassignProgramFromLearner = async (orgId: string,
    learnerId: string,
    learnerAssignmentId: string, options?: RequestInit): Promise<unassignProgramFromLearnerResponse> => {
  
  const res = await fetch(getUnassignProgramFromLearnerUrl(orgId,learnerId,learnerAssignmentId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unassignProgramFromLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unassignProgramFromLearnerResponse
}



/**
 * Staff marks a checkpoint as complete for a learner.
 * @summary Sign off on a checkpoint
 */
export type signCheckpointResponse201 = {
  data: CheckpointCompletion
  status: 201
}

export type signCheckpointResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type signCheckpointResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type signCheckpointResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type signCheckpointResponse404 = {
  data: NotFoundResponse
  status: 404
}

export type signCheckpointResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type signCheckpointResponseSuccess = (signCheckpointResponse201) & {
  headers: Headers;
};
export type signCheckpointResponseError = (signCheckpointResponse400 | signCheckpointResponse401 | signCheckpointResponse403 | signCheckpointResponse404 | signCheckpointResponse409) & {
  headers: Headers;
};

export type signCheckpointResponse = (signCheckpointResponseSuccess | signCheckpointResponseError)

export const getSignCheckpointUrl = (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,
    checkpointId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/program-assignments/${learnerAssignmentId}/checkpoints/${checkpointId}/sign`
}

export const signCheckpoint = async (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,
    checkpointId: string,
    checkpointSignRequest: CheckpointSignRequest, options?: RequestInit): Promise<signCheckpointResponse> => {
  
  const res = await fetch(getSignCheckpointUrl(orgId,learnerId,learnerAssignmentId,checkpointId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      checkpointSignRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: signCheckpointResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as signCheckpointResponse
}



/**
 * Staff revokes a checkpoint completion.
 * @summary Remove checkpoint signature
 */
export type unsignCheckpointResponse204 = {
  data: void
  status: 204
}

export type unsignCheckpointResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type unsignCheckpointResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type unsignCheckpointResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type unsignCheckpointResponseSuccess = (unsignCheckpointResponse204) & {
  headers: Headers;
};
export type unsignCheckpointResponseError = (unsignCheckpointResponse401 | unsignCheckpointResponse403 | unsignCheckpointResponse404) & {
  headers: Headers;
};

export type unsignCheckpointResponse = (unsignCheckpointResponseSuccess | unsignCheckpointResponseError)

export const getUnsignCheckpointUrl = (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,
    checkpointId: string,
    completionId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/program-assignments/${learnerAssignmentId}/checkpoints/${checkpointId}/unsign/${completionId}`
}

export const unsignCheckpoint = async (orgId: string,
    learnerId: string,
    learnerAssignmentId: string,
    checkpointId: string,
    completionId: string, options?: RequestInit): Promise<unsignCheckpointResponse> => {
  
  const res = await fetch(getUnsignCheckpointUrl(orgId,learnerId,learnerAssignmentId,checkpointId,completionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unsignCheckpointResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unsignCheckpointResponse
}



/**
 * Super admin only. Returns a paginated list of all user accounts.
 * @summary List users (platform-wide)
 */
export type listUsersResponse200 = {
  data: PagedUsers
  status: 200
}

export type listUsersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listUsersResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listUsersResponseSuccess = (listUsersResponse200) & {
  headers: Headers;
};
export type listUsersResponseError = (listUsersResponse401 | listUsersResponse403) & {
  headers: Headers;
};

export type listUsersResponse = (listUsersResponseSuccess | listUsersResponseError)

export const getListUsersUrl = (params?: ListUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users?${stringifiedParams}` : `/users`
}

export const listUsers = async (params?: ListUsersParams, options?: RequestInit): Promise<listUsersResponse> => {
  
  const res = await fetch(getListUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsersResponse
}



/**
 * Returns the user's profile information.
 * @summary Get user details (profile)
 */
export type getUserResponse200 = {
  data: User
  status: 200
}

export type getUserResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUserResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUserResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getUserResponseSuccess = (getUserResponse200) & {
  headers: Headers;
};
export type getUserResponseError = (getUserResponse401 | getUserResponse403 | getUserResponse404) & {
  headers: Headers;
};

export type getUserResponse = (getUserResponseSuccess | getUserResponseError)

export const getGetUserUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const getUser = async (userId: string, options?: RequestInit): Promise<getUserResponse> => {
  
  const res = await fetch(getGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserResponse
}



/**
 * Returns the user's preferences (locale, marketing opt-in, etc.).
 * @summary Get user settings
 */
export type getUserSettingsResponse200 = {
  data: UserSettings
  status: 200
}

export type getUserSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUserSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUserSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getUserSettingsResponseSuccess = (getUserSettingsResponse200) & {
  headers: Headers;
};
export type getUserSettingsResponseError = (getUserSettingsResponse401 | getUserSettingsResponse403 | getUserSettingsResponse404) & {
  headers: Headers;
};

export type getUserSettingsResponse = (getUserSettingsResponseSuccess | getUserSettingsResponseError)

export const getGetUserSettingsUrl = (userId: string,) => {


  

  return `/users/${userId}/settings`
}

export const getUserSettings = async (userId: string, options?: RequestInit): Promise<getUserSettingsResponse> => {
  
  const res = await fetch(getGetUserSettingsUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserSettingsResponse
}



/**
 * Partially updates the user's preferences.
 * @summary Update user settings
 */
export type updateUserSettingsResponse200 = {
  data: UserSettings
  status: 200
}

export type updateUserSettingsResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateUserSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateUserSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateUserSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateUserSettingsResponseSuccess = (updateUserSettingsResponse200) & {
  headers: Headers;
};
export type updateUserSettingsResponseError = (updateUserSettingsResponse400 | updateUserSettingsResponse401 | updateUserSettingsResponse403 | updateUserSettingsResponse404) & {
  headers: Headers;
};

export type updateUserSettingsResponse = (updateUserSettingsResponseSuccess | updateUserSettingsResponseError)

export const getUpdateUserSettingsUrl = (userId: string,) => {


  

  return `/users/${userId}/settings`
}

export const updateUserSettings = async (userId: string,
    userSettingsUpdateRequest: UserSettingsUpdateRequest, options?: RequestInit): Promise<updateUserSettingsResponse> => {
  
  const res = await fetch(getUpdateUserSettingsUrl(userId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSettingsUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserSettingsResponse
}



/**
 * Returns the organizations the user is a member of, together with their membership record (role, status).
 * @summary List orgs the user belongs to
 */
export type listUserOrgsResponse200 = {
  data: ListUserOrgs200
  status: 200
}

export type listUserOrgsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listUserOrgsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listUserOrgsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listUserOrgsResponseSuccess = (listUserOrgsResponse200) & {
  headers: Headers;
};
export type listUserOrgsResponseError = (listUserOrgsResponse401 | listUserOrgsResponse403 | listUserOrgsResponse404) & {
  headers: Headers;
};

export type listUserOrgsResponse = (listUserOrgsResponseSuccess | listUserOrgsResponseError)

export const getListUserOrgsUrl = (userId: string,) => {


  

  return `/users/${userId}/orgs`
}

export const listUserOrgs = async (userId: string, options?: RequestInit): Promise<listUserOrgsResponse> => {
  
  const res = await fetch(getListUserOrgsUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUserOrgsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUserOrgsResponse
}



/**
 * Super admin only. Returns a paginated list of all learner records.
 * @summary List learners (platform-wide)
 */
export type listLearnersResponse200 = {
  data: PagedLearners
  status: 200
}

export type listLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listLearnersResponseSuccess = (listLearnersResponse200) & {
  headers: Headers;
};
export type listLearnersResponseError = (listLearnersResponse401 | listLearnersResponse403) & {
  headers: Headers;
};

export type listLearnersResponse = (listLearnersResponseSuccess | listLearnersResponseError)

export const getListLearnersUrl = (params?: ListLearnersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/learners?${stringifiedParams}` : `/learners`
}

export const listLearners = async (params?: ListLearnersParams, options?: RequestInit): Promise<listLearnersResponse> => {
  
  const res = await fetch(getListLearnersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listLearnersResponse
}



/**
 * Returns a learner's global profile, independent of any organization.
 * @summary Get learner details (global)
 */
export type getLearnerResponse200 = {
  data: Learner
  status: 200
}

export type getLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getLearnerResponseSuccess = (getLearnerResponse200) & {
  headers: Headers;
};
export type getLearnerResponseError = (getLearnerResponse401 | getLearnerResponse403 | getLearnerResponse404) & {
  headers: Headers;
};

export type getLearnerResponse = (getLearnerResponseSuccess | getLearnerResponseError)

export const getGetLearnerUrl = (learnerId: string,) => {


  

  return `/learners/${learnerId}`
}

export const getLearner = async (learnerId: string, options?: RequestInit): Promise<getLearnerResponse> => {
  
  const res = await fetch(getGetLearnerUrl(learnerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLearnerResponse
}



/**
 * Returns a paginated list of all badges a learner has earned or is working toward across all orgs.
 * @summary List badges earned or in progress (global aggregation)
 */
export type listLearnerBadgesResponse200 = {
  data: PagedLearnerBadges
  status: 200
}

export type listLearnerBadgesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listLearnerBadgesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listLearnerBadgesResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listLearnerBadgesResponseSuccess = (listLearnerBadgesResponse200) & {
  headers: Headers;
};
export type listLearnerBadgesResponseError = (listLearnerBadgesResponse401 | listLearnerBadgesResponse403 | listLearnerBadgesResponse404) & {
  headers: Headers;
};

export type listLearnerBadgesResponse = (listLearnerBadgesResponseSuccess | listLearnerBadgesResponseError)

export const getListLearnerBadgesUrl = (learnerId: string,
    params?: ListLearnerBadgesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/learners/${learnerId}/badges?${stringifiedParams}` : `/learners/${learnerId}/badges`
}

export const listLearnerBadges = async (learnerId: string,
    params?: ListLearnerBadgesParams, options?: RequestInit): Promise<listLearnerBadgesResponse> => {
  
  const res = await fetch(getListLearnerBadgesUrl(learnerId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listLearnerBadgesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listLearnerBadgesResponse
}



/**
 * Returns the learner's full journey for a badge â€” progress across orgs, and any assertions earned. Used for shareable certificate pages.
 * @summary Learner journey for a specific badge
 */
export type getLearnerBadgeJourneyResponse200 = {
  data: LearnerBadgeJourney
  status: 200
}

export type getLearnerBadgeJourneyResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getLearnerBadgeJourneyResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getLearnerBadgeJourneyResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getLearnerBadgeJourneyResponseSuccess = (getLearnerBadgeJourneyResponse200) & {
  headers: Headers;
};
export type getLearnerBadgeJourneyResponseError = (getLearnerBadgeJourneyResponse401 | getLearnerBadgeJourneyResponse403 | getLearnerBadgeJourneyResponse404) & {
  headers: Headers;
};

export type getLearnerBadgeJourneyResponse = (getLearnerBadgeJourneyResponseSuccess | getLearnerBadgeJourneyResponseError)

export const getGetLearnerBadgeJourneyUrl = (learnerId: string,
    badgeId: string,) => {


  

  return `/learners/${learnerId}/badges/${badgeId}`
}

export const getLearnerBadgeJourney = async (learnerId: string,
    badgeId: string, options?: RequestInit): Promise<getLearnerBadgeJourneyResponse> => {
  
  const res = await fetch(getGetLearnerBadgeJourneyUrl(learnerId,badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLearnerBadgeJourneyResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLearnerBadgeJourneyResponse
}



/**
 * Returns a paginated list of badge definitions, optionally filtered by creating org.
 * @summary List badges
 */
export type listBadgesResponse200 = {
  data: PagedBadges
  status: 200
}

export type listBadgesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listBadgesResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listBadgesResponseSuccess = (listBadgesResponse200) & {
  headers: Headers;
};
export type listBadgesResponseError = (listBadgesResponse401 | listBadgesResponse403) & {
  headers: Headers;
};

export type listBadgesResponse = (listBadgesResponseSuccess | listBadgesResponseError)

export const getListBadgesUrl = (params?: ListBadgesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/badges?${stringifiedParams}` : `/badges`
}

export const listBadges = async (params?: ListBadgesParams, options?: RequestInit): Promise<listBadgesResponse> => {
  
  const res = await fetch(getListBadgesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBadgesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBadgesResponse
}



/**
 * Creates a new badge definition with optional criteria.
 * @summary Create a badge
 */
export type createBadgeResponse201 = {
  data: Badge
  status: 201
}

export type createBadgeResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createBadgeResponseSuccess = (createBadgeResponse201) & {
  headers: Headers;
};
export type createBadgeResponseError = (createBadgeResponse400 | createBadgeResponse401 | createBadgeResponse403) & {
  headers: Headers;
};

export type createBadgeResponse = (createBadgeResponseSuccess | createBadgeResponseError)

export const getCreateBadgeUrl = () => {


  

  return `/badges`
}

export const createBadge = async (badgeCreateRequest: BadgeCreateRequest, options?: RequestInit): Promise<createBadgeResponse> => {
  
  const res = await fetch(getCreateBadgeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createBadgeResponse
}



/**
 * Returns the full badge definition including criteria.
 * @summary Get badge details (Open Badges-aligned)
 */
export type getBadgeResponse200 = {
  data: Badge
  status: 200
}

export type getBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getBadgeResponseSuccess = (getBadgeResponse200) & {
  headers: Headers;
};
export type getBadgeResponseError = (getBadgeResponse401 | getBadgeResponse403 | getBadgeResponse404) & {
  headers: Headers;
};

export type getBadgeResponse = (getBadgeResponseSuccess | getBadgeResponseError)

export const getGetBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const getBadge = async (badgeId: string, options?: RequestInit): Promise<getBadgeResponse> => {
  
  const res = await fetch(getGetBadgeUrl(badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getBadgeResponse
}



/**
 * Partially updates a badge's name, description, image, or criteria.
 * @summary Update badge
 */
export type updateBadgeResponse200 = {
  data: Badge
  status: 200
}

export type updateBadgeResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateBadgeResponseSuccess = (updateBadgeResponse200) & {
  headers: Headers;
};
export type updateBadgeResponseError = (updateBadgeResponse400 | updateBadgeResponse401 | updateBadgeResponse403 | updateBadgeResponse404) & {
  headers: Headers;
};

export type updateBadgeResponse = (updateBadgeResponseSuccess | updateBadgeResponseError)

export const getUpdateBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const updateBadge = async (badgeId: string,
    badgeUpdateRequest: BadgeUpdateRequest, options?: RequestInit): Promise<updateBadgeResponse> => {
  
  const res = await fetch(getUpdateBadgeUrl(badgeId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateBadgeResponse
}



/**
 * Permanently deletes a badge definition. Existing issuances are not affected.
 * @summary Delete badge
 */
export type deleteBadgeResponse204 = {
  data: void
  status: 204
}

export type deleteBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteBadgeResponseSuccess = (deleteBadgeResponse204) & {
  headers: Headers;
};
export type deleteBadgeResponseError = (deleteBadgeResponse401 | deleteBadgeResponse403 | deleteBadgeResponse404) & {
  headers: Headers;
};

export type deleteBadgeResponse = (deleteBadgeResponseSuccess | deleteBadgeResponseError)

export const getDeleteBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const deleteBadge = async (badgeId: string, options?: RequestInit): Promise<deleteBadgeResponse> => {
  
  const res = await fetch(getDeleteBadgeUrl(badgeId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteBadgeResponse
}



/**
 * Returns a paginated list of badge collections.
 * @summary List collections
 */
export type listCollectionsResponse200 = {
  data: PagedCollections
  status: 200
}

export type listCollectionsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listCollectionsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listCollectionsResponseSuccess = (listCollectionsResponse200) & {
  headers: Headers;
};
export type listCollectionsResponseError = (listCollectionsResponse401 | listCollectionsResponse403) & {
  headers: Headers;
};

export type listCollectionsResponse = (listCollectionsResponseSuccess | listCollectionsResponseError)

export const getListCollectionsUrl = (params?: ListCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/collections?${stringifiedParams}` : `/collections`
}

export const listCollections = async (params?: ListCollectionsParams, options?: RequestInit): Promise<listCollectionsResponse> => {
  
  const res = await fetch(getListCollectionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCollectionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCollectionsResponse
}



/**
 * Creates a new collection of badges.
 * @summary Create collection
 */
export type createCollectionResponse201 = {
  data: Collection
  status: 201
}

export type createCollectionResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createCollectionResponseSuccess = (createCollectionResponse201) & {
  headers: Headers;
};
export type createCollectionResponseError = (createCollectionResponse400 | createCollectionResponse401 | createCollectionResponse403) & {
  headers: Headers;
};

export type createCollectionResponse = (createCollectionResponseSuccess | createCollectionResponseError)

export const getCreateCollectionUrl = () => {


  

  return `/collections`
}

export const createCollection = async (collectionCreateRequest: CollectionCreateRequest, options?: RequestInit): Promise<createCollectionResponse> => {
  
  const res = await fetch(getCreateCollectionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCollectionResponse
}



/**
 * Returns the collection and summaries of the badges it contains.
 * @summary Get collection details (includes some badge details)
 */
export type getCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type getCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getCollectionResponseSuccess = (getCollectionResponse200) & {
  headers: Headers;
};
export type getCollectionResponseError = (getCollectionResponse401 | getCollectionResponse403 | getCollectionResponse404) & {
  headers: Headers;
};

export type getCollectionResponse = (getCollectionResponseSuccess | getCollectionResponseError)

export const getGetCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const getCollection = async (collectionId: string, options?: RequestInit): Promise<getCollectionResponse> => {
  
  const res = await fetch(getGetCollectionUrl(collectionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCollectionResponse
}



/**
 * Partially updates a collection's metadata and/or its badge membership.
 * @summary Update collection (including add/remove badges)
 */
export type updateCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type updateCollectionResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateCollectionResponseSuccess = (updateCollectionResponse200) & {
  headers: Headers;
};
export type updateCollectionResponseError = (updateCollectionResponse400 | updateCollectionResponse401 | updateCollectionResponse403 | updateCollectionResponse404) & {
  headers: Headers;
};

export type updateCollectionResponse = (updateCollectionResponseSuccess | updateCollectionResponseError)

export const getUpdateCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const updateCollection = async (collectionId: string,
    collectionUpdateRequest: CollectionUpdateRequest, options?: RequestInit): Promise<updateCollectionResponse> => {
  
  const res = await fetch(getUpdateCollectionUrl(collectionId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCollectionResponse
}



/**
 * Permanently deletes a collection. Badges within it are not deleted.
 * @summary Delete collection
 */
export type deleteCollectionResponse204 = {
  data: void
  status: 204
}

export type deleteCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteCollectionResponseSuccess = (deleteCollectionResponse204) & {
  headers: Headers;
};
export type deleteCollectionResponseError = (deleteCollectionResponse401 | deleteCollectionResponse403 | deleteCollectionResponse404) & {
  headers: Headers;
};

export type deleteCollectionResponse = (deleteCollectionResponseSuccess | deleteCollectionResponseError)

export const getDeleteCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const deleteCollection = async (collectionId: string, options?: RequestInit): Promise<deleteCollectionResponse> => {
  
  const res = await fetch(getDeleteCollectionUrl(collectionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCollectionResponse
}



/**
 * Public browsing of published collections. No authentication required.
 * @summary Browse published collections in registry
 */
export type browseRegistryResponse200 = {
  data: PagedCollections
  status: 200
}
    
export type browseRegistryResponseSuccess = (browseRegistryResponse200) & {
  headers: Headers;
};
;

export type browseRegistryResponse = (browseRegistryResponseSuccess)

export const getBrowseRegistryUrl = (params?: BrowseRegistryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/registry/collections?${stringifiedParams}` : `/registry/collections`
}

export const browseRegistry = async (params?: BrowseRegistryParams, options?: RequestInit): Promise<browseRegistryResponse> => {
  
  const res = await fetch(getBrowseRegistryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: browseRegistryResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as browseRegistryResponse
}



/**
 * Makes a collection visible in the public registry.
 * @summary Publish a collection to registry
 */
export type publishCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type publishCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type publishCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type publishCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type publishCollectionResponseSuccess = (publishCollectionResponse200) & {
  headers: Headers;
};
export type publishCollectionResponseError = (publishCollectionResponse401 | publishCollectionResponse403 | publishCollectionResponse404) & {
  headers: Headers;
};

export type publishCollectionResponse = (publishCollectionResponseSuccess | publishCollectionResponseError)

export const getPublishCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/publish`
}

export const publishCollection = async (collectionId: string, options?: RequestInit): Promise<publishCollectionResponse> => {
  
  const res = await fetch(getPublishCollectionUrl(collectionId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: publishCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as publishCollectionResponse
}



/**
 * Removes a collection from the public registry.
 * @summary Unpublish a collection from registry
 */
export type unpublishCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type unpublishCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type unpublishCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type unpublishCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type unpublishCollectionResponseSuccess = (unpublishCollectionResponse200) & {
  headers: Headers;
};
export type unpublishCollectionResponseError = (unpublishCollectionResponse401 | unpublishCollectionResponse403 | unpublishCollectionResponse404) & {
  headers: Headers;
};

export type unpublishCollectionResponse = (unpublishCollectionResponseSuccess | unpublishCollectionResponseError)

export const getUnpublishCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/unpublish`
}

export const unpublishCollection = async (collectionId: string, options?: RequestInit): Promise<unpublishCollectionResponse> => {
  
  const res = await fetch(getUnpublishCollectionUrl(collectionId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unpublishCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unpublishCollectionResponse
}



/**
 * An org requests permission from the collection creator to issue its badges.
 * @summary Request authorization for an org to issue a collection
 */
export type requestIssueAuthorizationResponse201 = {
  data: IssueAuthorizationRequest
  status: 201
}

export type requestIssueAuthorizationResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type requestIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type requestIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type requestIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}

export type requestIssueAuthorizationResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type requestIssueAuthorizationResponseSuccess = (requestIssueAuthorizationResponse201) & {
  headers: Headers;
};
export type requestIssueAuthorizationResponseError = (requestIssueAuthorizationResponse400 | requestIssueAuthorizationResponse401 | requestIssueAuthorizationResponse403 | requestIssueAuthorizationResponse404 | requestIssueAuthorizationResponse409) & {
  headers: Headers;
};

export type requestIssueAuthorizationResponse = (requestIssueAuthorizationResponseSuccess | requestIssueAuthorizationResponseError)

export const getRequestIssueAuthorizationUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/issue-authorizations`
}

export const requestIssueAuthorization = async (collectionId: string,
    issueAuthorizationRequestCreate: IssueAuthorizationRequestCreate, options?: RequestInit): Promise<requestIssueAuthorizationResponse> => {
  
  const res = await fetch(getRequestIssueAuthorizationUrl(collectionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      issueAuthorizationRequestCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: requestIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as requestIssueAuthorizationResponse
}



/**
 * Returns authorization requests for the collection, for the creator to review.
 * @summary List authorization requests for this collection (creator review)
 */
export type listIssueAuthorizationsResponse200 = {
  data: PagedIssueAuthorizationRequests
  status: 200
}

export type listIssueAuthorizationsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listIssueAuthorizationsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listIssueAuthorizationsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listIssueAuthorizationsResponseSuccess = (listIssueAuthorizationsResponse200) & {
  headers: Headers;
};
export type listIssueAuthorizationsResponseError = (listIssueAuthorizationsResponse401 | listIssueAuthorizationsResponse403 | listIssueAuthorizationsResponse404) & {
  headers: Headers;
};

export type listIssueAuthorizationsResponse = (listIssueAuthorizationsResponseSuccess | listIssueAuthorizationsResponseError)

export const getListIssueAuthorizationsUrl = (collectionId: string,
    params?: ListIssueAuthorizationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/collections/${collectionId}/issue-authorizations?${stringifiedParams}` : `/collections/${collectionId}/issue-authorizations`
}

export const listIssueAuthorizations = async (collectionId: string,
    params?: ListIssueAuthorizationsParams, options?: RequestInit): Promise<listIssueAuthorizationsResponse> => {
  
  const res = await fetch(getListIssueAuthorizationsUrl(collectionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listIssueAuthorizationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listIssueAuthorizationsResponse
}



/**
 * Grants an org the authorization to issue badges from the collection.
 * @summary Approve issue authorization request
 */
export type approveIssueAuthorizationResponse200 = {
  data: IssueAuthorization
  status: 200
}

export type approveIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type approveIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type approveIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type approveIssueAuthorizationResponseSuccess = (approveIssueAuthorizationResponse200) & {
  headers: Headers;
};
export type approveIssueAuthorizationResponseError = (approveIssueAuthorizationResponse401 | approveIssueAuthorizationResponse403 | approveIssueAuthorizationResponse404) & {
  headers: Headers;
};

export type approveIssueAuthorizationResponse = (approveIssueAuthorizationResponseSuccess | approveIssueAuthorizationResponseError)

export const getApproveIssueAuthorizationUrl = (authRequestId: string,) => {


  

  return `/issue-authorizations/${authRequestId}/approve`
}

export const approveIssueAuthorization = async (authRequestId: string, options?: RequestInit): Promise<approveIssueAuthorizationResponse> => {
  
  const res = await fetch(getApproveIssueAuthorizationUrl(authRequestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: approveIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as approveIssueAuthorizationResponse
}



/**
 * Denies an org's request to issue badges from the collection.
 * @summary Reject issue authorization request
 */
export type rejectIssueAuthorizationResponse204 = {
  data: void
  status: 204
}

export type rejectIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type rejectIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type rejectIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type rejectIssueAuthorizationResponseSuccess = (rejectIssueAuthorizationResponse204) & {
  headers: Headers;
};
export type rejectIssueAuthorizationResponseError = (rejectIssueAuthorizationResponse401 | rejectIssueAuthorizationResponse403 | rejectIssueAuthorizationResponse404) & {
  headers: Headers;
};

export type rejectIssueAuthorizationResponse = (rejectIssueAuthorizationResponseSuccess | rejectIssueAuthorizationResponseError)

export const getRejectIssueAuthorizationUrl = (authRequestId: string,) => {


  

  return `/issue-authorizations/${authRequestId}/reject`
}

export const rejectIssueAuthorization = async (authRequestId: string, options?: RequestInit): Promise<rejectIssueAuthorizationResponse> => {
  
  const res = await fetch(getRejectIssueAuthorizationUrl(authRequestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rejectIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rejectIssueAuthorizationResponse
}



/**
 * Returns the publicly verifiable assertion data for an issued badge. No authentication required.
 * @summary Public verification payload for an issued badge (Assertion)
 */
export type getPublicAssertionResponse200 = {
  data: Assertion
  status: 200
}

export type getPublicAssertionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getPublicAssertionResponseSuccess = (getPublicAssertionResponse200) & {
  headers: Headers;
};
export type getPublicAssertionResponseError = (getPublicAssertionResponse404) & {
  headers: Headers;
};

export type getPublicAssertionResponse = (getPublicAssertionResponseSuccess | getPublicAssertionResponseError)

export const getGetPublicAssertionUrl = (assertionId: string,) => {


  

  return `/public/assertions/${assertionId}`
}

export const getPublicAssertion = async (assertionId: string, options?: RequestInit): Promise<getPublicAssertionResponse> => {
  
  const res = await fetch(getGetPublicAssertionUrl(assertionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPublicAssertionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPublicAssertionResponse
}



/**
 * @summary List an org's credential library (collection relationships)
 */
export type listOrgCollectionRelsResponse200 = {
  data: PagedOrgCollectionRels
  status: 200
}

export type listOrgCollectionRelsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgCollectionRelsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listOrgCollectionRelsResponseSuccess = (listOrgCollectionRelsResponse200) & {
  headers: Headers;
};
export type listOrgCollectionRelsResponseError = (listOrgCollectionRelsResponse401 | listOrgCollectionRelsResponse403) & {
  headers: Headers;
};

export type listOrgCollectionRelsResponse = (listOrgCollectionRelsResponseSuccess | listOrgCollectionRelsResponseError)

export const getListOrgCollectionRelsUrl = (orgId: string,
    params?: ListOrgCollectionRelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/library/collections?${stringifiedParams}` : `/orgs/${orgId}/library/collections`
}

export const listOrgCollectionRels = async (orgId: string,
    params?: ListOrgCollectionRelsParams, options?: RequestInit): Promise<listOrgCollectionRelsResponse> => {
  
  const res = await fetch(getListOrgCollectionRelsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgCollectionRelsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgCollectionRelsResponse
}



/**
 * @summary Get a single collection relationship with badge roster
 */
export type getOrgCollectionRelResponse200 = {
  data: OrgCollectionRelDetail
  status: 200
}

export type getOrgCollectionRelResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgCollectionRelResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgCollectionRelResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgCollectionRelResponseSuccess = (getOrgCollectionRelResponse200) & {
  headers: Headers;
};
export type getOrgCollectionRelResponseError = (getOrgCollectionRelResponse401 | getOrgCollectionRelResponse403 | getOrgCollectionRelResponse404) & {
  headers: Headers;
};

export type getOrgCollectionRelResponse = (getOrgCollectionRelResponseSuccess | getOrgCollectionRelResponseError)

export const getGetOrgCollectionRelUrl = (orgId: string,
    collectionRelId: string,) => {


  

  return `/orgs/${orgId}/library/collections/${collectionRelId}`
}

export const getOrgCollectionRel = async (orgId: string,
    collectionRelId: string, options?: RequestInit): Promise<getOrgCollectionRelResponse> => {
  
  const res = await fetch(getGetOrgCollectionRelUrl(orgId,collectionRelId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgCollectionRelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgCollectionRelResponse
}



/**
 * @summary Update a collection relationship (admin only)
 */
export type updateOrgCollectionRelResponse200 = {
  data: OrgCollectionRel
  status: 200
}

export type updateOrgCollectionRelResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgCollectionRelResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgCollectionRelResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgCollectionRelResponseSuccess = (updateOrgCollectionRelResponse200) & {
  headers: Headers;
};
export type updateOrgCollectionRelResponseError = (updateOrgCollectionRelResponse401 | updateOrgCollectionRelResponse403 | updateOrgCollectionRelResponse404) & {
  headers: Headers;
};

export type updateOrgCollectionRelResponse = (updateOrgCollectionRelResponseSuccess | updateOrgCollectionRelResponseError)

export const getUpdateOrgCollectionRelUrl = (orgId: string,
    collectionRelId: string,) => {


  

  return `/orgs/${orgId}/library/collections/${collectionRelId}`
}

export const updateOrgCollectionRel = async (orgId: string,
    collectionRelId: string,
    orgCollectionRelUpdateRequest: OrgCollectionRelUpdateRequest, options?: RequestInit): Promise<updateOrgCollectionRelResponse> => {
  
  const res = await fetch(getUpdateOrgCollectionRelUrl(orgId,collectionRelId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgCollectionRelUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgCollectionRelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgCollectionRelResponse
}



/**
 * @summary List an org's badge relationships across its library
 */
export type listOrgBadgeRelsResponse200 = {
  data: PagedOrgBadgeRels
  status: 200
}

export type listOrgBadgeRelsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgBadgeRelsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listOrgBadgeRelsResponseSuccess = (listOrgBadgeRelsResponse200) & {
  headers: Headers;
};
export type listOrgBadgeRelsResponseError = (listOrgBadgeRelsResponse401 | listOrgBadgeRelsResponse403) & {
  headers: Headers;
};

export type listOrgBadgeRelsResponse = (listOrgBadgeRelsResponseSuccess | listOrgBadgeRelsResponseError)

export const getListOrgBadgeRelsUrl = (orgId: string,
    params?: ListOrgBadgeRelsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/library/badges?${stringifiedParams}` : `/orgs/${orgId}/library/badges`
}

export const listOrgBadgeRels = async (orgId: string,
    params?: ListOrgBadgeRelsParams, options?: RequestInit): Promise<listOrgBadgeRelsResponse> => {
  
  const res = await fetch(getListOrgBadgeRelsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgBadgeRelsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgBadgeRelsResponse
}



/**
 * @summary Get a single badge relationship with full badge detail
 */
export type getOrgBadgeRelResponse200 = {
  data: OrgBadgeRelDetail
  status: 200
}

export type getOrgBadgeRelResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgBadgeRelResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgBadgeRelResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgBadgeRelResponseSuccess = (getOrgBadgeRelResponse200) & {
  headers: Headers;
};
export type getOrgBadgeRelResponseError = (getOrgBadgeRelResponse401 | getOrgBadgeRelResponse403 | getOrgBadgeRelResponse404) & {
  headers: Headers;
};

export type getOrgBadgeRelResponse = (getOrgBadgeRelResponseSuccess | getOrgBadgeRelResponseError)

export const getGetOrgBadgeRelUrl = (orgId: string,
    badgeRelId: string,) => {


  

  return `/orgs/${orgId}/library/badges/${badgeRelId}`
}

export const getOrgBadgeRel = async (orgId: string,
    badgeRelId: string, options?: RequestInit): Promise<getOrgBadgeRelResponse> => {
  
  const res = await fetch(getGetOrgBadgeRelUrl(orgId,badgeRelId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgBadgeRelResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgBadgeRelResponse
}



/**
 * @summary Library-level analytics summary for an org
 */
export type getOrgLibraryAnalyticsResponse200 = {
  data: CredLibraryAnalytics
  status: 200
}

export type getOrgLibraryAnalyticsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgLibraryAnalyticsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type getOrgLibraryAnalyticsResponseSuccess = (getOrgLibraryAnalyticsResponse200) & {
  headers: Headers;
};
export type getOrgLibraryAnalyticsResponseError = (getOrgLibraryAnalyticsResponse401 | getOrgLibraryAnalyticsResponse403) & {
  headers: Headers;
};

export type getOrgLibraryAnalyticsResponse = (getOrgLibraryAnalyticsResponseSuccess | getOrgLibraryAnalyticsResponseError)

export const getGetOrgLibraryAnalyticsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/library/analytics`
}

export const getOrgLibraryAnalytics = async (orgId: string, options?: RequestInit): Promise<getOrgLibraryAnalyticsResponse> => {
  
  const res = await fetch(getGetOrgLibraryAnalyticsUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgLibraryAnalyticsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgLibraryAnalyticsResponse
}



/**
 * @summary Analytics for a specific collection relationship
 */
export type getOrgCollectionRelAnalyticsResponse200 = {
  data: CredCollectionAnalytics
  status: 200
}

export type getOrgCollectionRelAnalyticsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgCollectionRelAnalyticsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgCollectionRelAnalyticsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgCollectionRelAnalyticsResponseSuccess = (getOrgCollectionRelAnalyticsResponse200) & {
  headers: Headers;
};
export type getOrgCollectionRelAnalyticsResponseError = (getOrgCollectionRelAnalyticsResponse401 | getOrgCollectionRelAnalyticsResponse403 | getOrgCollectionRelAnalyticsResponse404) & {
  headers: Headers;
};

export type getOrgCollectionRelAnalyticsResponse = (getOrgCollectionRelAnalyticsResponseSuccess | getOrgCollectionRelAnalyticsResponseError)

export const getGetOrgCollectionRelAnalyticsUrl = (orgId: string,
    collectionRelId: string,) => {


  

  return `/orgs/${orgId}/library/analytics/collections/${collectionRelId}`
}

export const getOrgCollectionRelAnalytics = async (orgId: string,
    collectionRelId: string, options?: RequestInit): Promise<getOrgCollectionRelAnalyticsResponse> => {
  
  const res = await fetch(getGetOrgCollectionRelAnalyticsUrl(orgId,collectionRelId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgCollectionRelAnalyticsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgCollectionRelAnalyticsResponse
}



/**
 * @summary Analytics for a specific badge relationship
 */
export type getOrgBadgeRelAnalyticsResponse200 = {
  data: CredBadgeAnalytics
  status: 200
}

export type getOrgBadgeRelAnalyticsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgBadgeRelAnalyticsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgBadgeRelAnalyticsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgBadgeRelAnalyticsResponseSuccess = (getOrgBadgeRelAnalyticsResponse200) & {
  headers: Headers;
};
export type getOrgBadgeRelAnalyticsResponseError = (getOrgBadgeRelAnalyticsResponse401 | getOrgBadgeRelAnalyticsResponse403 | getOrgBadgeRelAnalyticsResponse404) & {
  headers: Headers;
};

export type getOrgBadgeRelAnalyticsResponse = (getOrgBadgeRelAnalyticsResponseSuccess | getOrgBadgeRelAnalyticsResponseError)

export const getGetOrgBadgeRelAnalyticsUrl = (orgId: string,
    badgeRelId: string,) => {


  

  return `/orgs/${orgId}/library/analytics/badges/${badgeRelId}`
}

export const getOrgBadgeRelAnalytics = async (orgId: string,
    badgeRelId: string, options?: RequestInit): Promise<getOrgBadgeRelAnalyticsResponse> => {
  
  const res = await fetch(getGetOrgBadgeRelAnalyticsUrl(orgId,badgeRelId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgBadgeRelAnalyticsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgBadgeRelAnalyticsResponse
}


export const getRegisterResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getLoginResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getRefreshTokenResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getCreateOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 30}}), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListOrgsResponseMock = (overrideResponse: Partial< PagedOrgs > = {}): PagedOrgs => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 30}}), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 30}}), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 30}}), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetOrgSettingsResponseMock = (overrideResponse: Partial< OrgSettings > = {}): OrgSettings => ({allowSelfJoin: faker.datatype.boolean(), requireAdminApprovalForJoin: faker.datatype.boolean(), defaultMemberRole: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getUpdateOrgSettingsResponseMock = (overrideResponse: Partial< OrgSettings > = {}): OrgSettings => ({allowSelfJoin: faker.datatype.boolean(), requireAdminApprovalForJoin: faker.datatype.boolean(), defaultMemberRole: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetOrgStatsResponseMock = (overrideResponse: Partial< OrgStats > = {}): OrgStats => ({totalMembers: faker.number.int({min: undefined, max: undefined}), totalLearners: faker.number.int({min: undefined, max: undefined}), totalBadges: faker.number.int({min: undefined, max: undefined}), totalIssuances: faker.number.int({min: undefined, max: undefined}), activeLearners: faker.number.int({min: undefined, max: undefined}), badgesIssuedThisMonth: faker.number.int({min: undefined, max: undefined}), badgesIssuedThisYear: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getListOrgMembersResponseMock = (overrideResponse: Partial< PagedOrgMemberDetails > = {}): PagedOrgMemberDetails => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{user: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, undefined])},})), ...overrideResponse})

export const getGetOrgMemberResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgMemberResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getCreateMembershipRequestResponseMock = (overrideResponse: Partial< MembershipRequest > = {}): MembershipRequest => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected','canceled'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListMembershipRequestsResponseMock = (overrideResponse: Partial< PagedMembershipRequests > = {}): PagedMembershipRequests => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected','canceled'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getApproveMembershipRequestResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListOrgLearnersResponseMock = (overrideResponse: Partial< PagedOrgLearners > = {}): PagedOrgLearners => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), badgeProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), issuances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), undefined])},})), ...overrideResponse})

export const getCreateOrgLearnerResponseMock = (overrideResponse: Partial< OrgLearner > = {}): OrgLearner => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getBulkImportOrgLearnersResponseMock = (overrideResponse: Partial< ImportJob > = {}): ImportJob => ({id: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['queued','running','complete','failed'] as const), totalCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), successCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), errorCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), errors: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getGetOrgLearnerResponseMock = (): OrgLearnerDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), badgeProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), issuances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), undefined])},})

export const getGetOrgLearnerBadgeProgressResponseMock = (overrideResponse: Partial< BadgeProgress > = {}): BadgeProgress => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgLearnerBadgeProgressResponseMock = (overrideResponse: Partial< BadgeProgress > = {}): BadgeProgress => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getCreateIssuanceResponseMock = (overrideResponse: Partial< Issuance > = {}): Issuance => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined]), ...overrideResponse})

export const getListIssuancesResponseMock = (overrideResponse: Partial< PagedIssuances > = {}): PagedIssuances => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), ...overrideResponse})

export const getListCohortsResponseMock = (overrideResponse: Partial< PagedCohorts > = {}): PagedCohorts => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','draft','archived'] as const), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), assignedStaffIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), learnerCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateCohortResponseMock = (overrideResponse: Partial< Cohort > = {}): Cohort => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','draft','archived'] as const), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), assignedStaffIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), learnerCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetCohortResponseMock = (): CohortDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','draft','archived'] as const), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), assignedStaffIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), learnerCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learners: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])},})

export const getUpdateCohortResponseMock = (overrideResponse: Partial< Cohort > = {}): Cohort => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','draft','archived'] as const), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), assignedStaffIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), learnerCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getAddCohortLearnersResponseMock = (): CohortDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','draft','archived'] as const), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), assignedStaffIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), learnerCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learners: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), undefined])},})

export const getListProgramsResponseMock = (overrideResponse: Partial< PagedPrograms > = {}): PagedPrograms => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateProgramResponseMock = (): ProgramDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},})

export const getGetProgramResponseMock = (): ProgramDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},})

export const getUpdateProgramResponseMock = (): ProgramDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},})

export const getListCohortProgramAssignmentsResponseMock = (overrideResponse: Partial< PagedCohortProgramAssignments > = {}): PagedCohortProgramAssignments => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), cohortId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), cohort: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}})}, undefined]), learnerAssignmentCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])},})), ...overrideResponse})

export const getAssignProgramToCohortResponseMock = (): CohortProgramAssignmentDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), cohortId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), cohort: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}})}, undefined]), learnerAssignmentCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])},})

export const getGetCohortProgramAssignmentResponseMock = (): CohortProgramAssignmentDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), cohortId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), cohort: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}})}, undefined]), learnerAssignmentCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])},})

export const getListLearnerProgramAssignmentsResponseMock = (overrideResponse: Partial< PagedLearnerProgramAssignments > = {}): PagedLearnerProgramAssignments => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), cohortAssignmentId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined]), completedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), phaseProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), isComplete: faker.datatype.boolean()})), undefined]), checkpointCompletions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), assignmentId: faker.string.alpha({length: {min: 10, max: 20}}), checkpointId: faker.string.alpha({length: {min: 10, max: 20}}), signedBy: faker.string.alpha({length: {min: 10, max: 20}}), signedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 1000}}), undefined])})), undefined])}, undefined])},})), ...overrideResponse})

export const getAssignProgramToLearnerResponseMock = (): LearnerProgramAssignmentDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), cohortAssignmentId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined]), completedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), phaseProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), isComplete: faker.datatype.boolean()})), undefined]), checkpointCompletions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), assignmentId: faker.string.alpha({length: {min: 10, max: 20}}), checkpointId: faker.string.alpha({length: {min: 10, max: 20}}), signedBy: faker.string.alpha({length: {min: 10, max: 20}}), signedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 1000}}), undefined])})), undefined])}, undefined])},})

export const getGetLearnerProgramAssignmentResponseMock = (): LearnerProgramAssignmentDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), programId: faker.string.alpha({length: {min: 10, max: 20}}), cohortAssignmentId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), assignedBy: faker.string.alpha({length: {min: 10, max: 20}}), assignedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', phaseDueDates: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), dueDate: faker.date.past().toISOString().slice(0, 19) + 'Z'})), undefined]), completedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{program: faker.helpers.arrayElement([{...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), status: faker.helpers.arrayElement(['draft','active','archived'] as const), phaseCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalBadgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), totalCheckpointCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{phases: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), order: faker.number.int({min: undefined, max: undefined}), badges: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), checkpoints: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])}))})), undefined])},}, undefined]), learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])}, undefined]), progress: faker.helpers.arrayElement([{badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), phaseProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({phaseId: faker.string.alpha({length: {min: 10, max: 20}}), badgesEarned: faker.number.int({min: undefined, max: undefined}), badgesTotal: faker.number.int({min: undefined, max: undefined}), checkpointsSigned: faker.number.int({min: undefined, max: undefined}), checkpointsTotal: faker.number.int({min: undefined, max: undefined}), isComplete: faker.datatype.boolean()})), undefined]), checkpointCompletions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), assignmentId: faker.string.alpha({length: {min: 10, max: 20}}), checkpointId: faker.string.alpha({length: {min: 10, max: 20}}), signedBy: faker.string.alpha({length: {min: 10, max: 20}}), signedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 1000}}), undefined])})), undefined])}, undefined])},})

export const getSignCheckpointResponseMock = (overrideResponse: Partial< CheckpointCompletion > = {}): CheckpointCompletion => ({id: faker.string.alpha({length: {min: 10, max: 20}}), assignmentId: faker.string.alpha({length: {min: 10, max: 20}}), checkpointId: faker.string.alpha({length: {min: 10, max: 20}}), signedBy: faker.string.alpha({length: {min: 10, max: 20}}), signedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 1000}}), undefined]), ...overrideResponse})

export const getListUsersResponseMock = (overrideResponse: Partial< PagedUsers > = {}): PagedUsers => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetUserResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 500}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 120}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetUserSettingsResponseMock = (overrideResponse: Partial< UserSettings > = {}): UserSettings => ({locale: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), marketingEmails: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getUpdateUserSettingsResponseMock = (overrideResponse: Partial< UserSettings > = {}): UserSettings => ({locale: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), marketingEmails: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getListUserOrgsResponseMock = (overrideResponse: Partial< ListUserOrgs200 > = {}): ListUserOrgs200 => ({data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({org: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.helpers.fromRegExp('^[a-z0-9]+(?:-[a-z0-9]+)*$'), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), phone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 30}}), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 200}}), undefined]), socialLinks: faker.helpers.arrayElement([{linkedin: faker.helpers.arrayElement([faker.internet.url(), undefined]), website: faker.helpers.arrayElement([faker.internet.url(), undefined]), x: faker.helpers.arrayElement([faker.internet.url(), undefined])}, undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, membership: {id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}})), ...overrideResponse})

export const getListLearnersResponseMock = (overrideResponse: Partial< PagedLearners > = {}): PagedLearners => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined])})), ...overrideResponse})

export const getGetLearnerResponseMock = (overrideResponse: Partial< Learner > = {}): Learner => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), slug: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), profileImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), coverImageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), bio: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), title: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), location: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getListLearnerBadgesResponseMock = (overrideResponse: Partial< PagedLearnerBadges > = {}): PagedLearnerBadges => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, progressByOrg: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), assertions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])})), ...overrideResponse})

export const getGetLearnerBadgeJourneyResponseMock = (overrideResponse: Partial< LearnerBadgeJourney > = {}): LearnerBadgeJourney => ({learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, progressByOrg: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), assertions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), ...overrideResponse})

export const getListBadgesResponseMock = (overrideResponse: Partial< PagedBadges > = {}): PagedBadges => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListCollectionsResponseMock = (overrideResponse: Partial< PagedCollections > = {}): PagedCollections => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateCollectionResponseMock = (overrideResponse: Partial< Collection > = {}): Collection => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), stats: faker.helpers.arrayElement([{totalIssuances: faker.number.int({min: undefined, max: undefined}), uniqueLearners: faker.number.int({min: undefined, max: undefined}), badgeCount: faker.number.int({min: undefined, max: undefined}), averageCompletionRate: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined])},})

export const getUpdateCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), stats: faker.helpers.arrayElement([{totalIssuances: faker.number.int({min: undefined, max: undefined}), uniqueLearners: faker.number.int({min: undefined, max: undefined}), badgeCount: faker.number.int({min: undefined, max: undefined}), averageCompletionRate: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined])},})

export const getBrowseRegistryResponseMock = (overrideResponse: Partial< PagedCollections > = {}): PagedCollections => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getPublishCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), stats: faker.helpers.arrayElement([{totalIssuances: faker.number.int({min: undefined, max: undefined}), uniqueLearners: faker.number.int({min: undefined, max: undefined}), badgeCount: faker.number.int({min: undefined, max: undefined}), averageCompletionRate: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined])},})

export const getUnpublishCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])})), undefined]), stats: faker.helpers.arrayElement([{totalIssuances: faker.number.int({min: undefined, max: undefined}), uniqueLearners: faker.number.int({min: undefined, max: undefined}), badgeCount: faker.number.int({min: undefined, max: undefined}), averageCompletionRate: faker.helpers.arrayElement([faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), undefined])}, undefined])},})

export const getRequestIssueAuthorizationResponseMock = (overrideResponse: Partial< IssueAuthorizationRequest > = {}): IssueAuthorizationRequest => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), requestingOrgId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListIssueAuthorizationsResponseMock = (overrideResponse: Partial< PagedIssueAuthorizationRequests > = {}): PagedIssueAuthorizationRequests => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), requestingOrgId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getApproveIssueAuthorizationResponseMock = (overrideResponse: Partial< IssueAuthorization > = {}): IssueAuthorization => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), grantedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetPublicAssertionResponseMock = (overrideResponse: Partial< Assertion > = {}): Assertion => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})

export const getListOrgCollectionRelsResponseMock = (overrideResponse: Partial< PagedOrgCollectionRels > = {}): PagedOrgCollectionRels => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived','rejected'] as const), source: faker.helpers.arrayElement(['owned','authorized'] as const), programCount: faker.number.int({min: undefined, max: undefined}), authRequestId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), collection: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, requestedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), approvedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), statusChangedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetOrgCollectionRelResponseMock = (): OrgCollectionRelDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived','rejected'] as const), source: faker.helpers.arrayElement(['owned','authorized'] as const), programCount: faker.number.int({min: undefined, max: undefined}), authRequestId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), collection: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, requestedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), approvedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), statusChangedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeRels: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), collectionRelId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived'] as const), programCount: faker.number.int({min: undefined, max: undefined}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}}))},})

export const getUpdateOrgCollectionRelResponseMock = (overrideResponse: Partial< OrgCollectionRel > = {}): OrgCollectionRel => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived','rejected'] as const), source: faker.helpers.arrayElement(['owned','authorized'] as const), programCount: faker.number.int({min: undefined, max: undefined}), authRequestId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), collection: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, requestedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), approvedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), statusChangedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListOrgBadgeRelsResponseMock = (overrideResponse: Partial< PagedOrgBadgeRels > = {}): PagedOrgBadgeRels => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), collectionRelId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived'] as const), programCount: faker.number.int({min: undefined, max: undefined}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}})), ...overrideResponse})

export const getGetOrgBadgeRelResponseMock = (): OrgBadgeRelDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), collectionRelId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived'] as const), programCount: faker.number.int({min: undefined, max: undefined}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), issuanceCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined])}},...{badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, collectionRel: {id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','active','archived','rejected'] as const), source: faker.helpers.arrayElement(['owned','authorized'] as const), programCount: faker.number.int({min: undefined, max: undefined}), authRequestId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), notes: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), collection: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, requestedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), approvedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), statusChangedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}},})

export const getGetOrgLibraryAnalyticsResponseMock = (overrideResponse: Partial< CredLibraryAnalytics > = {}): CredLibraryAnalytics => ({adoptionFunnel: {viewedInCatalog: faker.number.int({min: undefined, max: undefined}), requested: faker.number.int({min: undefined, max: undefined}), approved: faker.number.int({min: undefined, max: undefined}), activeInLibrary: faker.number.int({min: undefined, max: undefined}), referencedInPrograms: faker.number.int({min: undefined, max: undefined})}, unusedActiveCount: faker.number.int({min: undefined, max: undefined}), avgTimeToApprovalDays: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), topCollections: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({collectionRelId: faker.string.alpha({length: {min: 10, max: 20}}), collectionName: faker.string.alpha({length: {min: 10, max: 20}}), programCount: faker.number.int({min: undefined, max: undefined})})), ...overrideResponse})

export const getGetOrgCollectionRelAnalyticsResponseMock = (overrideResponse: Partial< CredCollectionAnalytics > = {}): CredCollectionAnalytics => ({collectionRelId: faker.string.alpha({length: {min: 10, max: 20}}), collection: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), badgeCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, programCount: faker.number.int({min: undefined, max: undefined}), programs: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}})})), badgeAdoption: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({badgeRelId: faker.string.alpha({length: {min: 10, max: 20}}), badgeName: faker.string.alpha({length: {min: 10, max: 20}}), programCount: faker.number.int({min: undefined, max: undefined})})), ...overrideResponse})

export const getGetOrgBadgeRelAnalyticsResponseMock = (overrideResponse: Partial< CredBadgeAnalytics > = {}): CredBadgeAnalytics => ({badgeRelId: faker.string.alpha({length: {min: 10, max: 20}}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, programCount: faker.number.int({min: undefined, max: undefined}), programs: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), slug: faker.string.alpha({length: {min: 10, max: 20}})})), ...overrideResponse})


export const getRegisterMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/register', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRegisterResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getLoginMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/login', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRefreshTokenMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/refresh', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRefreshTokenResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getLogoutMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/auth/logout', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getCreateOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.post('*/auth/createorg', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateOrgResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgsMockHandler = (overrideResponse?: PagedOrgs | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgs> | PagedOrgs), options?: RequestHandlerOptions) => {
  return http.get('*/orgs', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgSettingsMockHandler = (overrideResponse?: OrgSettings | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgSettings> | OrgSettings), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgSettingsMockHandler = (overrideResponse?: OrgSettings | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<OrgSettings> | OrgSettings), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgStatsMockHandler = (overrideResponse?: OrgStats | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgStats> | OrgStats), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/stats', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgStatsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgMembersMockHandler = (overrideResponse?: PagedOrgMemberDetails | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgMemberDetails> | PagedOrgMemberDetails), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/members', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgMembersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgMemberMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/members/:memberId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgMemberResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgMemberMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/members/:memberId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgMemberResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateMembershipRequestMockHandler = (overrideResponse?: MembershipRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MembershipRequest> | MembershipRequest), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateMembershipRequestResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListMembershipRequestsMockHandler = (overrideResponse?: PagedMembershipRequests | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedMembershipRequests> | PagedMembershipRequests), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/membership-requests', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListMembershipRequestsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApproveMembershipRequestMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests/:requestId/approve', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApproveMembershipRequestResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRejectMembershipRequestMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests/:requestId/reject', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListOrgLearnersMockHandler = (overrideResponse?: PagedOrgLearners | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgLearners> | PagedOrgLearners), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateOrgLearnerMockHandler = (overrideResponse?: OrgLearner | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<OrgLearner> | OrgLearner), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateOrgLearnerResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getBulkImportOrgLearnersMockHandler = (overrideResponse?: ImportJob | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ImportJob> | ImportJob), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners\:bulk-import', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getBulkImportOrgLearnersResponseMock()),
      { status: 202,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgLearnerMockHandler = (overrideResponse?: OrgLearnerDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgLearnerDetail> | OrgLearnerDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgLearnerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgLearnerBadgeProgressMockHandler = (overrideResponse?: BadgeProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<BadgeProgress> | BadgeProgress), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgLearnerBadgeProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgLearnerBadgeProgressMockHandler = (overrideResponse?: BadgeProgress | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<BadgeProgress> | BadgeProgress), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgLearnerBadgeProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateIssuanceMockHandler = (overrideResponse?: Issuance | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Issuance> | Issuance), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/issuances', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateIssuanceResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListIssuancesMockHandler = (overrideResponse?: PagedIssuances | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedIssuances> | PagedIssuances), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/issuances', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListIssuancesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListCohortsMockHandler = (overrideResponse?: PagedCohorts | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCohorts> | PagedCohorts), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListCohortsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateCohortMockHandler = (overrideResponse?: Cohort | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Cohort> | Cohort), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/cohorts', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateCohortResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetCohortMockHandler = (overrideResponse?: CohortDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CohortDetail> | CohortDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetCohortResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateCohortMockHandler = (overrideResponse?: Cohort | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Cohort> | Cohort), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateCohortResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteCohortMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getAddCohortLearnersMockHandler = (overrideResponse?: CohortDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CohortDetail> | CohortDetail), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/cohorts/:cohortId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAddCohortLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRemoveCohortLearnerMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/cohorts/:cohortId/learners/:learnerId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListProgramsMockHandler = (overrideResponse?: PagedPrograms | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedPrograms> | PagedPrograms), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/programs', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListProgramsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateProgramMockHandler = (overrideResponse?: ProgramDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ProgramDetail> | ProgramDetail), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/programs', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateProgramResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetProgramMockHandler = (overrideResponse?: ProgramDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ProgramDetail> | ProgramDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/programs/:programSlug', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetProgramResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateProgramMockHandler = (overrideResponse?: ProgramDetail | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<ProgramDetail> | ProgramDetail), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/programs/:programSlug', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateProgramResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteProgramMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/programs/:programSlug', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListCohortProgramAssignmentsMockHandler = (overrideResponse?: PagedCohortProgramAssignments | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCohortProgramAssignments> | PagedCohortProgramAssignments), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts/:cohortId/program-assignments', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListCohortProgramAssignmentsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getAssignProgramToCohortMockHandler = (overrideResponse?: CohortProgramAssignmentDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CohortProgramAssignmentDetail> | CohortProgramAssignmentDetail), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/cohorts/:cohortId/program-assignments', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAssignProgramToCohortResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetCohortProgramAssignmentMockHandler = (overrideResponse?: CohortProgramAssignmentDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CohortProgramAssignmentDetail> | CohortProgramAssignmentDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts/:cohortId/program-assignments/:cohortAssignmentId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetCohortProgramAssignmentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUnassignProgramFromCohortMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/cohorts/:cohortId/program-assignments/:cohortAssignmentId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListLearnerProgramAssignmentsMockHandler = (overrideResponse?: PagedLearnerProgramAssignments | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedLearnerProgramAssignments> | PagedLearnerProgramAssignments), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId/program-assignments', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListLearnerProgramAssignmentsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getAssignProgramToLearnerMockHandler = (overrideResponse?: LearnerProgramAssignmentDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LearnerProgramAssignmentDetail> | LearnerProgramAssignmentDetail), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners/:learnerId/program-assignments', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAssignProgramToLearnerResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetLearnerProgramAssignmentMockHandler = (overrideResponse?: LearnerProgramAssignmentDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LearnerProgramAssignmentDetail> | LearnerProgramAssignmentDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId/program-assignments/:learnerAssignmentId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetLearnerProgramAssignmentResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUnassignProgramFromLearnerMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/learners/:learnerId/program-assignments/:learnerAssignmentId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getSignCheckpointMockHandler = (overrideResponse?: CheckpointCompletion | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CheckpointCompletion> | CheckpointCompletion), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners/:learnerId/program-assignments/:learnerAssignmentId/checkpoints/:checkpointId/sign', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSignCheckpointResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUnsignCheckpointMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/learners/:learnerId/program-assignments/:learnerAssignmentId/checkpoints/:checkpointId/unsign/:completionId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListUsersMockHandler = (overrideResponse?: PagedUsers | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedUsers> | PagedUsers), options?: RequestHandlerOptions) => {
  return http.get('*/users', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetUserMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.get('*/users/:userId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetUserSettingsMockHandler = (overrideResponse?: UserSettings | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserSettings> | UserSettings), options?: RequestHandlerOptions) => {
  return http.get('*/users/:userId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateUserSettingsMockHandler = (overrideResponse?: UserSettings | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UserSettings> | UserSettings), options?: RequestHandlerOptions) => {
  return http.patch('*/users/:userId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateUserSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListUserOrgsMockHandler = (overrideResponse?: ListUserOrgs200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<ListUserOrgs200> | ListUserOrgs200), options?: RequestHandlerOptions) => {
  return http.get('*/users/:userId/orgs', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUserOrgsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListLearnersMockHandler = (overrideResponse?: PagedLearners | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedLearners> | PagedLearners), options?: RequestHandlerOptions) => {
  return http.get('*/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetLearnerMockHandler = (overrideResponse?: Learner | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Learner> | Learner), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetLearnerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListLearnerBadgesMockHandler = (overrideResponse?: PagedLearnerBadges | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedLearnerBadges> | PagedLearnerBadges), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListLearnerBadgesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetLearnerBadgeJourneyMockHandler = (overrideResponse?: LearnerBadgeJourney | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LearnerBadgeJourney> | LearnerBadgeJourney), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetLearnerBadgeJourneyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListBadgesMockHandler = (overrideResponse?: PagedBadges | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedBadges> | PagedBadges), options?: RequestHandlerOptions) => {
  return http.get('*/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListBadgesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.post('*/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateBadgeResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.get('*/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetBadgeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.patch('*/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateBadgeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteBadgeMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/badges/:badgeId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListCollectionsMockHandler = (overrideResponse?: PagedCollections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCollections> | PagedCollections), options?: RequestHandlerOptions) => {
  return http.get('*/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListCollectionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateCollectionMockHandler = (overrideResponse?: Collection | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Collection> | Collection), options?: RequestHandlerOptions) => {
  return http.post('*/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateCollectionResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.get('*/collections/:collectionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.patch('*/collections/:collectionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteCollectionMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/collections/:collectionId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getBrowseRegistryMockHandler = (overrideResponse?: PagedCollections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCollections> | PagedCollections), options?: RequestHandlerOptions) => {
  return http.get('*/registry/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getBrowseRegistryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPublishCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/publish', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPublishCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUnpublishCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/unpublish', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUnpublishCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRequestIssueAuthorizationMockHandler = (overrideResponse?: IssueAuthorizationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<IssueAuthorizationRequest> | IssueAuthorizationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/issue-authorizations', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRequestIssueAuthorizationResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListIssueAuthorizationsMockHandler = (overrideResponse?: PagedIssueAuthorizationRequests | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedIssueAuthorizationRequests> | PagedIssueAuthorizationRequests), options?: RequestHandlerOptions) => {
  return http.get('*/collections/:collectionId/issue-authorizations', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListIssueAuthorizationsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApproveIssueAuthorizationMockHandler = (overrideResponse?: IssueAuthorization | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<IssueAuthorization> | IssueAuthorization), options?: RequestHandlerOptions) => {
  return http.post('*/issue-authorizations/:authRequestId/approve', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApproveIssueAuthorizationResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRejectIssueAuthorizationMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/issue-authorizations/:authRequestId/reject', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getGetPublicAssertionMockHandler = (overrideResponse?: Assertion | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Assertion> | Assertion), options?: RequestHandlerOptions) => {
  return http.get('*/public/assertions/:assertionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetPublicAssertionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgCollectionRelsMockHandler = (overrideResponse?: PagedOrgCollectionRels | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgCollectionRels> | PagedOrgCollectionRels), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgCollectionRelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgCollectionRelMockHandler = (overrideResponse?: OrgCollectionRelDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgCollectionRelDetail> | OrgCollectionRelDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/collections/:collectionRelId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgCollectionRelResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgCollectionRelMockHandler = (overrideResponse?: OrgCollectionRel | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<OrgCollectionRel> | OrgCollectionRel), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/library/collections/:collectionRelId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgCollectionRelResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgBadgeRelsMockHandler = (overrideResponse?: PagedOrgBadgeRels | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgBadgeRels> | PagedOrgBadgeRels), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgBadgeRelsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgBadgeRelMockHandler = (overrideResponse?: OrgBadgeRelDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgBadgeRelDetail> | OrgBadgeRelDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/badges/:badgeRelId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgBadgeRelResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgLibraryAnalyticsMockHandler = (overrideResponse?: CredLibraryAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CredLibraryAnalytics> | CredLibraryAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/analytics', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgLibraryAnalyticsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgCollectionRelAnalyticsMockHandler = (overrideResponse?: CredCollectionAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CredCollectionAnalytics> | CredCollectionAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/analytics/collections/:collectionRelId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgCollectionRelAnalyticsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgBadgeRelAnalyticsMockHandler = (overrideResponse?: CredBadgeAnalytics | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CredBadgeAnalytics> | CredBadgeAnalytics), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/library/analytics/badges/:badgeRelId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgBadgeRelAnalyticsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}
export const getBadgingAppAPIV0Mock = () => [
  getRegisterMockHandler(),
  getLoginMockHandler(),
  getRefreshTokenMockHandler(),
  getLogoutMockHandler(),
  getCreateOrgMockHandler(),
  getListOrgsMockHandler(),
  getGetOrgMockHandler(),
  getUpdateOrgMockHandler(),
  getGetOrgSettingsMockHandler(),
  getUpdateOrgSettingsMockHandler(),
  getGetOrgStatsMockHandler(),
  getListOrgMembersMockHandler(),
  getGetOrgMemberMockHandler(),
  getUpdateOrgMemberMockHandler(),
  getCreateMembershipRequestMockHandler(),
  getListMembershipRequestsMockHandler(),
  getApproveMembershipRequestMockHandler(),
  getRejectMembershipRequestMockHandler(),
  getListOrgLearnersMockHandler(),
  getCreateOrgLearnerMockHandler(),
  getBulkImportOrgLearnersMockHandler(),
  getGetOrgLearnerMockHandler(),
  getGetOrgLearnerBadgeProgressMockHandler(),
  getUpdateOrgLearnerBadgeProgressMockHandler(),
  getCreateIssuanceMockHandler(),
  getListIssuancesMockHandler(),
  getListCohortsMockHandler(),
  getCreateCohortMockHandler(),
  getGetCohortMockHandler(),
  getUpdateCohortMockHandler(),
  getDeleteCohortMockHandler(),
  getAddCohortLearnersMockHandler(),
  getRemoveCohortLearnerMockHandler(),
  getListProgramsMockHandler(),
  getCreateProgramMockHandler(),
  getGetProgramMockHandler(),
  getUpdateProgramMockHandler(),
  getDeleteProgramMockHandler(),
  getListCohortProgramAssignmentsMockHandler(),
  getAssignProgramToCohortMockHandler(),
  getGetCohortProgramAssignmentMockHandler(),
  getUnassignProgramFromCohortMockHandler(),
  getListLearnerProgramAssignmentsMockHandler(),
  getAssignProgramToLearnerMockHandler(),
  getGetLearnerProgramAssignmentMockHandler(),
  getUnassignProgramFromLearnerMockHandler(),
  getSignCheckpointMockHandler(),
  getUnsignCheckpointMockHandler(),
  getListUsersMockHandler(),
  getGetUserMockHandler(),
  getGetUserSettingsMockHandler(),
  getUpdateUserSettingsMockHandler(),
  getListUserOrgsMockHandler(),
  getListLearnersMockHandler(),
  getGetLearnerMockHandler(),
  getListLearnerBadgesMockHandler(),
  getGetLearnerBadgeJourneyMockHandler(),
  getListBadgesMockHandler(),
  getCreateBadgeMockHandler(),
  getGetBadgeMockHandler(),
  getUpdateBadgeMockHandler(),
  getDeleteBadgeMockHandler(),
  getListCollectionsMockHandler(),
  getCreateCollectionMockHandler(),
  getGetCollectionMockHandler(),
  getUpdateCollectionMockHandler(),
  getDeleteCollectionMockHandler(),
  getBrowseRegistryMockHandler(),
  getPublishCollectionMockHandler(),
  getUnpublishCollectionMockHandler(),
  getRequestIssueAuthorizationMockHandler(),
  getListIssueAuthorizationsMockHandler(),
  getApproveIssueAuthorizationMockHandler(),
  getRejectIssueAuthorizationMockHandler(),
  getGetPublicAssertionMockHandler(),
  getListOrgCollectionRelsMockHandler(),
  getGetOrgCollectionRelMockHandler(),
  getUpdateOrgCollectionRelMockHandler(),
  getListOrgBadgeRelsMockHandler(),
  getGetOrgBadgeRelMockHandler(),
  getGetOrgLibraryAnalyticsMockHandler(),
  getGetOrgCollectionRelAnalyticsMockHandler(),
  getGetOrgBadgeRelAnalyticsMockHandler()
]
