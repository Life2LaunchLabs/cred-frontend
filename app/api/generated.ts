/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * Badging App API (v0)
 * v0 OpenAPI spec for org/staff/learner/badge/collection management with JWT auth + RBAC. Auth is enforced by required permissions (vendor extension `x-permissions`) and org-scope checks.

 * OpenAPI spec version: 0.1.0
 */
import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  http
} from 'msw';
import type {
  RequestHandlerOptions
} from 'msw';

/**
 * ISO 8601 date-time string.
 */
export type ISODateTime = string;

/**
 * Pagination metadata included in all list responses.
 */
export interface PagedMeta {
  /** Current page number. */
  page: number;
  /** Items per page. */
  pageSize: number;
  /** Total number of items. */
  total: number;
}

/**
 * Standard error envelope returned for all non-2xx responses.
 */
export interface ErrorResponse {
  /** Human-readable error message. */
  message: string;
  /** Machine-readable error code for programmatic handling. */
  code?: string;
}

/**
 * Payload for user registration.
 */
export interface RegisterRequest {
  /** User's email address. Must be unique. */
  email: string;
  /**
   * Account password.
   * @minLength 8
   * @maxLength 128
   */
  password: string;
  /**
   * User's display name.
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
}

/**
 * Payload for user login.
 */
export interface LoginRequest {
  /** Registered email address. */
  email: string;
  /** Account password. */
  password: string;
}

/**
 * Payload for token refresh.
 */
export interface RefreshRequest {
  /** The refresh token issued during login or a previous refresh. */
  refreshToken: string;
}

/**
 * A platform user account.
 */
export interface User {
  /** Unique user identifier. */
  id: string;
  /** User's email address. */
  email: string;
  /** User's display name. */
  name?: string;
  createdAt?: ISODateTime;
}

/**
 * Returned on successful authentication (login, register, or refresh).
 */
export interface AuthResponse {
  /** Short-lived JWT access token for API authorization. */
  accessToken: string;
  /** Long-lived refresh token for obtaining new access tokens. */
  refreshToken?: string;
  user: User;
}

/**
 * Per-user preference settings.
 */
export interface UserSettings {
  /** Preferred locale for the UI. */
  locale?: string;
  /** Whether the user has opted in to marketing emails. */
  marketingEmails?: boolean;
}

/**
 * Partial update for user settings.
 */
export interface UserSettingsUpdateRequest {
  locale?: string;
  marketingEmails?: boolean;
}

export interface PagedUsers {
  meta: PagedMeta;
  data: User[];
}

/**
 * An organization that manages staff, learners, and badge issuance.
 */
export interface Org {
  /** Unique organization identifier. */
  id: string;
  /** Organization display name. */
  name: string;
  /** Short description or bio for the organization. */
  about?: string;
  /** URL to the organization's logo or avatar image. */
  imageUrl?: string;
  /** Public contact email for the organization. */
  contactEmail?: string;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * Payload for creating an organization.
 */
export interface OrgCreateRequest {
  /**
   * Organization name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Short description of the organization.
   * @maxLength 2000
   */
  about?: string;
  /** Public contact email. */
  contactEmail?: string;
}

/**
 * Partial update for an organization's profile.
 */
export interface OrgUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  about?: string;
  imageUrl?: string;
  contactEmail?: string;
}

/**
 * Organization-level settings controlling membership policies.
 */
export interface OrgSettings {
  /** Whether users can join this org without an invite. */
  allowSelfJoin: boolean;
  /** Whether join requests require admin approval. */
  requireAdminApprovalForJoin: boolean;
  /** Default role assigned to new members. */
  defaultMemberRole?: string;
}

/**
 * Partial update for organization settings.
 */
export interface OrgSettingsUpdateRequest {
  allowSelfJoin?: boolean;
  requireAdminApprovalForJoin?: boolean;
  defaultMemberRole?: string;
}

export interface PagedOrgs {
  meta: PagedMeta;
  data: Org[];
}

/**
 * The member's role within the org.
 */
export type OrgMemberRole = typeof OrgMemberRole[keyof typeof OrgMemberRole];


export const OrgMemberRole = {
  owner: 'owner',
  admin: 'admin',
  issuer: 'issuer',
  viewer: 'viewer',
} as const;

/**
 * Current membership status.
 */
export type OrgMemberStatus = typeof OrgMemberStatus[keyof typeof OrgMemberStatus];


export const OrgMemberStatus = {
  active: 'active',
  invited: 'invited',
  suspended: 'suspended',
} as const;

/**
 * A staff membership record linking a user to an organization with a specific role.
 */
export interface OrgMember {
  /** Unique membership record identifier. */
  id: string;
  /** The organization this membership belongs to. */
  orgId: string;
  /** The user who holds this membership. */
  userId: string;
  /** The member's role within the org. */
  role: OrgMemberRole;
  /** Current membership status. */
  status: OrgMemberStatus;
  createdAt?: ISODateTime;
}

export type OrgMemberUpdateRequestRole = typeof OrgMemberUpdateRequestRole[keyof typeof OrgMemberUpdateRequestRole];


export const OrgMemberUpdateRequestRole = {
  owner: 'owner',
  admin: 'admin',
  issuer: 'issuer',
  viewer: 'viewer',
} as const;

export type OrgMemberUpdateRequestStatus = typeof OrgMemberUpdateRequestStatus[keyof typeof OrgMemberUpdateRequestStatus];


export const OrgMemberUpdateRequestStatus = {
  active: 'active',
  suspended: 'suspended',
} as const;

/**
 * Partial update for a membership record.
 */
export interface OrgMemberUpdateRequest {
  role?: OrgMemberUpdateRequestRole;
  status?: OrgMemberUpdateRequestStatus;
}

export interface PagedOrgMembers {
  meta: PagedMeta;
  data: OrgMember[];
}

/**
 * Payload for creating a membership request (self-join or admin invite).
 */
export interface MembershipRequestCreate {
  /** Target user ID. If omitted, the request is for the authenticated user. */
  userId?: string;
  /**
   * Optional message from the requester.
   * @maxLength 1000
   */
  message?: string;
}

/**
 * Current request status.
 */
export type MembershipRequestStatus = typeof MembershipRequestStatus[keyof typeof MembershipRequestStatus];


export const MembershipRequestStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  canceled: 'canceled',
} as const;

/**
 * A request for a user to become a member of an organization.
 */
export interface MembershipRequest {
  /** Unique request identifier. */
  id: string;
  /** Target organization. */
  orgId: string;
  /** Requesting user. */
  userId: string;
  /** Current request status. */
  status: MembershipRequestStatus;
  /** Optional message from the requester. */
  message?: string;
  createdAt?: ISODateTime;
}

export interface PagedMembershipRequests {
  meta: PagedMeta;
  data: MembershipRequest[];
}

/**
 * A learner's global profile, independent of any organization.
 */
export interface Learner {
  /** Unique learner identifier. */
  id: string;
  /** Learner's display name. */
  name?: string;
  /** Learner's email address (may be null for externally provisioned learners). */
  email?: string;
  createdAt?: ISODateTime;
}

/**
 * Whether this learner is active or archived in the org.
 */
export type OrgLearnerStatus = typeof OrgLearnerStatus[keyof typeof OrgLearnerStatus];


export const OrgLearnerStatus = {
  active: 'active',
  archived: 'archived',
} as const;

/**
 * A learner's affiliation with an organization, including org-specific metadata.
 */
export interface OrgLearner {
  /** Unique org-learner record identifier. */
  id: string;
  /** The organization this learner is affiliated with. */
  orgId: string;
  /** The learner's global ID. */
  learnerId: string;
  /** External reference such as a roster ID or SIS ID. */
  externalRef?: string;
  /** Whether this learner is active or archived in the org. */
  status: OrgLearnerStatus;
  createdAt?: ISODateTime;
}

/**
 * Payload for provisioning a learner in an organization.
 */
export interface OrgLearnerCreateRequest {
  /**
   * Learner's display name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /** Learner's email address. */
  email?: string;
  /**
   * External roster or SIS identifier.
   * @maxLength 255
   */
  externalRef?: string;
}

/**
 * Current progress status.
 */
export type BadgeProgressStatus = typeof BadgeProgressStatus[keyof typeof BadgeProgressStatus];


export const BadgeProgressStatus = {
  not_started: 'not_started',
  in_progress: 'in_progress',
  complete: 'complete',
} as const;

/**
 * Tracks a learner's progress toward earning a badge within a specific org.
 */
export interface BadgeProgress {
  /** The org in which this progress is tracked. */
  orgId: string;
  /** The learner this progress belongs to. */
  learnerId: string;
  /** The badge being worked toward. */
  badgeId: string;
  /** Current progress status. */
  status: BadgeProgressStatus;
  /** IDs of criteria the learner has completed. */
  completedCriteriaIds?: string[];
  updatedAt?: ISODateTime;
}

/**
 * Current issuance status.
 */
export type IssuanceStatus = typeof IssuanceStatus[keyof typeof IssuanceStatus];


export const IssuanceStatus = {
  issued: 'issued',
  revoked: 'revoked',
} as const;

/**
 * Record of a badge being issued to a learner by an org.
 */
export interface Issuance {
  /** Unique issuance identifier. */
  id: string;
  /** The org that issued the badge. */
  orgId: string;
  /** The learner who received the badge. */
  learnerId: string;
  /** The badge that was issued. */
  badgeId: string;
  /** The public assertion ID for verification. */
  assertionId: string;
  /** Current issuance status. */
  status: IssuanceStatus;
  issuedAt: ISODateTime;
  /** When the issuance was revoked, if applicable. */
  revokedAt?: ISODateTime | null;
}

export type OrgLearnerDetail = OrgLearner & {
  learner?: Learner;
  /** Badge progress records for this learner within this org. */
  badgeProgress?: BadgeProgress[];
  /** Badge issuances for this learner within this org. */
  issuances?: Issuance[];
};

export interface PagedLearners {
  meta: PagedMeta;
  data: Learner[];
}

export interface PagedOrgLearners {
  meta: PagedMeta;
  data: OrgLearnerDetail[];
}

/**
 * Payload for bulk-importing learners into an organization.
 */
export interface BulkLearnerImportRequest {
  /** List of learner records to import. */
  learners: OrgLearnerCreateRequest[];
}

/**
 * Current job status.
 */
export type ImportJobStatus = typeof ImportJobStatus[keyof typeof ImportJobStatus];


export const ImportJobStatus = {
  queued: 'queued',
  running: 'running',
  complete: 'complete',
  failed: 'failed',
} as const;

/**
 * Status of an asynchronous bulk import job.
 */
export interface ImportJob {
  /** Unique job identifier. */
  id: string;
  /** Current job status. */
  status: ImportJobStatus;
  /** Total number of records in the import. */
  totalCount?: number;
  /** Number of records successfully imported so far. */
  successCount?: number;
  /** Number of records that failed to import. */
  errorCount?: number;
  createdAt?: ISODateTime;
  /** Error messages for individual failed records. */
  errors?: string[];
}

/**
 * A single criterion within a badge definition.
 */
export interface BadgeCriteriaItem {
  /** Unique criterion identifier. */
  id: string;
  /** Human-readable description of the criterion. */
  label: string;
  /** Whether this criterion is required to earn the badge. */
  isRequired?: boolean;
}

/**
 * A badge definition including its criteria. Aligned with Open Badges concepts.
 */
export interface Badge {
  /** Unique badge identifier. */
  id: string;
  /** Badge display name. */
  name: string;
  /** Detailed description of what this badge represents. */
  description?: string;
  /** URL to the badge image. */
  imageUrl?: string;
  /** List of criteria that must be met to earn this badge. */
  criteria?: BadgeCriteriaItem[];
  /** The org that created this badge. */
  createdByOrgId?: string;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

/**
 * Payload for creating a badge.
 */
export interface BadgeCreateRequest {
  /**
   * Badge name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Badge description.
   * @maxLength 2000
   */
  description?: string;
  /** URL to the badge image. */
  imageUrl?: string;
  /** Initial criteria for the badge. */
  criteria?: BadgeCriteriaItem[];
  /** The org creating this badge. */
  createdByOrgId: string;
}

/**
 * Partial update for a badge definition.
 */
export interface BadgeUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
  imageUrl?: string;
  criteria?: BadgeCriteriaItem[];
}

export interface PagedBadges {
  meta: PagedMeta;
  data: Badge[];
}

export type BadgeProgressUpdateRequestStatus = typeof BadgeProgressUpdateRequestStatus[keyof typeof BadgeProgressUpdateRequestStatus];


export const BadgeProgressUpdateRequestStatus = {
  in_progress: 'in_progress',
  complete: 'complete',
} as const;

/**
 * Partial update for a learner's badge progress.
 */
export interface BadgeProgressUpdateRequest {
  status?: BadgeProgressUpdateRequestStatus;
  completedCriteriaIds?: string[];
}

/**
 * Payload for issuing a badge to a learner.
 */
export interface IssuanceCreateRequest {
  /** The learner receiving the badge. */
  learnerId: string;
  /** The badge being issued. */
  badgeId: string;
  /** Optional URL to supporting evidence. */
  evidenceUrl?: string;
}

export interface PagedIssuances {
  meta: PagedMeta;
  data: Issuance[];
}

/**
 * Public verification payload for an issued badge, aligned with Open Badges concepts.
 */
export interface Assertion {
  /** Unique assertion identifier. */
  id: string;
  /** The org that issued the badge. */
  issuerOrgId: string;
  /** The learner who earned the badge. */
  recipientLearnerId: string;
  /** The badge that was earned. */
  badgeId: string;
  issuedAt: ISODateTime;
  /** Optional URL to supporting evidence. */
  evidenceUrl?: string;
}

/**
 * A learner's full journey for a specific badge across all orgs.
 */
export interface LearnerBadgeJourney {
  /** The learner. */
  learnerId: string;
  badge: Badge;
  /** Progress records from each org tracking this badge. */
  progressByOrg?: BadgeProgress[];
  /** Assertions earned for this badge. */
  assertions?: Assertion[];
}

export interface PagedLearnerBadges {
  meta: PagedMeta;
  data: LearnerBadgeJourney[];
}

/**
 * A curated group of badges, optionally published to the public registry.
 */
export interface Collection {
  /** Unique collection identifier. */
  id: string;
  /** Collection display name. */
  name: string;
  /** Description of the collection's purpose. */
  description?: string;
  /** The org that created this collection. */
  createdByOrgId: string;
  /** Whether this collection is visible in the public registry. */
  published?: boolean;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

export type CollectionDetail = Collection & {
  /** Summary of each badge in the collection. */
  badgeSummaries?: {
  id: string;
  name: string;
  imageUrl?: string;
}[];
};

/**
 * Payload for creating a collection.
 */
export interface CollectionCreateRequest {
  /**
   * Collection name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Collection description.
   * @maxLength 2000
   */
  description?: string;
  /** The org creating this collection. */
  createdByOrgId: string;
  /** Initial badge IDs to include in the collection. */
  badgeIds?: string[];
}

/**
 * Partial update for a collection, including adding or removing badges.
 */
export interface CollectionUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
  /** Badge IDs to add to the collection. */
  addBadgeIds?: string[];
  /** Badge IDs to remove from the collection. */
  removeBadgeIds?: string[];
}

export interface PagedCollections {
  meta: PagedMeta;
  data: Collection[];
}

/**
 * Payload for requesting authorization to issue badges from a collection.
 */
export interface IssueAuthorizationRequestCreate {
  /** The org requesting issuance authorization. */
  requestingOrgId: string;
  /**
   * Optional message explaining the request.
   * @maxLength 1000
   */
  message?: string;
}

/**
 * Current request status.
 */
export type IssueAuthorizationRequestStatus = typeof IssueAuthorizationRequestStatus[keyof typeof IssueAuthorizationRequestStatus];


export const IssueAuthorizationRequestStatus = {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
} as const;

/**
 * A request from an org to be authorized to issue badges from a collection.
 */
export interface IssueAuthorizationRequest {
  /** Unique request identifier. */
  id: string;
  /** The collection being requested. */
  collectionId: string;
  /** The org requesting authorization. */
  requestingOrgId: string;
  /** Current request status. */
  status: IssueAuthorizationRequestStatus;
  /** Optional message from the requester. */
  message?: string;
  createdAt?: ISODateTime;
}

/**
 * A granted authorization for an org to issue badges from a collection.
 */
export interface IssueAuthorization {
  /** Unique authorization identifier. */
  id: string;
  /** The authorized collection. */
  collectionId: string;
  /** The authorized org. */
  orgId: string;
  grantedAt?: ISODateTime;
}

export interface PagedIssueAuthorizationRequests {
  meta: PagedMeta;
  data: IssueAuthorizationRequest[];
}

/**
 * A named group of learners within an organization.
 */
export interface Cohort {
  /** Unique cohort identifier. */
  id: string;
  /** The org this cohort belongs to. */
  orgId: string;
  /** Cohort display name. */
  name: string;
  /** Optional description of the cohort. */
  description?: string;
  createdAt?: ISODateTime;
  updatedAt?: ISODateTime;
}

export type CohortDetail = Cohort & {
  /** Learners in this cohort. */
  learners?: Learner[];
};

/**
 * Payload for creating a cohort.
 */
export interface CohortCreateRequest {
  /**
   * Cohort name.
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * Optional description.
   * @maxLength 2000
   */
  description?: string;
}

/**
 * Partial update for a cohort.
 */
export interface CohortUpdateRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /** @maxLength 2000 */
  description?: string;
}

/**
 * Payload for adding learners to a cohort.
 */
export interface CohortLearnersAddRequest {
  /** List of learner IDs to add. */
  learnerIds: string[];
}

export interface PagedCohorts {
  meta: PagedMeta;
  data: Cohort[];
}

/**
 * Validation error
 */
export type BadRequestResponse = ErrorResponse;

/**
 * Missing or invalid authentication token
 */
export type UnauthorizedResponse = ErrorResponse;

/**
 * Insufficient permissions
 */
export type ForbiddenResponse = ErrorResponse;

/**
 * Resource not found
 */
export type NotFoundResponse = ErrorResponse;

/**
 * Page number (1-indexed).
 */
export type PageParameter = number;

/**
 * Number of items per page.
 */
export type PageSizeParameter = number;

/**
 * Keyword search.
 */
export type QueryParameter = string;

export type ListOrgsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Optional structured filter (implementation-defined).
 */
filter?: { [key: string]: unknown };
};

export type ListOrgMembersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListMembershipRequestsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListOrgLearnersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListIssuancesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Filter issuances by learner.
 */
learnerId?: string;
/**
 * Filter issuances by badge.
 */
badgeId?: string;
/**
 * Filter by issuance status.
 */
status?: ListIssuancesStatus;
};

export type ListIssuancesStatus = typeof ListIssuancesStatus[keyof typeof ListIssuancesStatus];


export const ListIssuancesStatus = {
  issued: 'issued',
  revoked: 'revoked',
} as const;

export type ListCohortsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListUsersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListLearnersParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListLearnerBadgesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

export type ListBadgesParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
/**
 * Filter badges by creator org.
 */
orgId?: string;
};

export type ListCollectionsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type BrowseRegistryParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
/**
 * Keyword search.
 */
q?: QueryParameter;
};

export type ListIssueAuthorizationsParams = {
/**
 * Page number (1-indexed).
 * @minimum 1
 */
page?: PageParameter;
/**
 * Number of items per page.
 * @minimum 1
 * @maximum 200
 */
pageSize?: PageSizeParameter;
};

/**
 * Creates a new user account and returns JWT tokens. Email must be unique.
 * @summary Register a user account
 */
export type registerResponse201 = {
  data: AuthResponse
  status: 201
}

export type registerResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type registerResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type registerResponseSuccess = (registerResponse201) & {
  headers: Headers;
};
export type registerResponseError = (registerResponse400 | registerResponse409) & {
  headers: Headers;
};

export type registerResponse = (registerResponseSuccess | registerResponseError)

export const getRegisterUrl = () => {


  

  return `/auth/register`
}

export const register = async (registerRequest: RegisterRequest, options?: RequestInit): Promise<registerResponse> => {
  
  const res = await fetch(getRegisterUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      registerRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: registerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as registerResponse
}



/**
 * Authenticates a user by email and password, returning JWT tokens.
 * @summary Login and receive JWT access token
 */
export type loginResponse200 = {
  data: AuthResponse
  status: 200
}

export type loginResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type loginResponseSuccess = (loginResponse200) & {
  headers: Headers;
};
export type loginResponseError = (loginResponse401) & {
  headers: Headers;
};

export type loginResponse = (loginResponseSuccess | loginResponseError)

export const getLoginUrl = () => {


  

  return `/auth/login`
}

export const login = async (loginRequest: LoginRequest, options?: RequestInit): Promise<loginResponse> => {
  
  const res = await fetch(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginResponse
}



/**
 * Exchanges a valid refresh token for a new access/refresh token pair.
 * @summary Refresh access token
 */
export type refreshTokenResponse200 = {
  data: AuthResponse
  status: 200
}

export type refreshTokenResponse401 = {
  data: ErrorResponse
  status: 401
}
    
export type refreshTokenResponseSuccess = (refreshTokenResponse200) & {
  headers: Headers;
};
export type refreshTokenResponseError = (refreshTokenResponse401) & {
  headers: Headers;
};

export type refreshTokenResponse = (refreshTokenResponseSuccess | refreshTokenResponseError)

export const getRefreshTokenUrl = () => {


  

  return `/auth/refresh`
}

export const refreshToken = async (refreshRequest: RefreshRequest, options?: RequestInit): Promise<refreshTokenResponse> => {
  
  const res = await fetch(getRefreshTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      refreshRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: refreshTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as refreshTokenResponse
}



/**
 * Invalidates the current session and refresh token.
 * @summary Logout (invalidate refresh token / session)
 */
export type logoutResponse204 = {
  data: void
  status: 204
}

export type logoutResponse401 = {
  data: UnauthorizedResponse
  status: 401
}
    
export type logoutResponseSuccess = (logoutResponse204) & {
  headers: Headers;
};
export type logoutResponseError = (logoutResponse401) & {
  headers: Headers;
};

export type logoutResponse = (logoutResponseSuccess | logoutResponseError)

export const getLogoutUrl = () => {


  

  return `/auth/logout`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  const res = await fetch(getLogoutUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: logoutResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as logoutResponse
}



/**
 * Creates a new organization. The authenticated user becomes the owner.
 * @summary Create a new organization
 */
export type createOrgResponse201 = {
  data: Org
  status: 201
}

export type createOrgResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createOrgResponseSuccess = (createOrgResponse201) & {
  headers: Headers;
};
export type createOrgResponseError = (createOrgResponse400 | createOrgResponse401 | createOrgResponse403) & {
  headers: Headers;
};

export type createOrgResponse = (createOrgResponseSuccess | createOrgResponseError)

export const getCreateOrgUrl = () => {


  

  return `/auth/createorg`
}

export const createOrg = async (orgCreateRequest: OrgCreateRequest, options?: RequestInit): Promise<createOrgResponse> => {
  
  const res = await fetch(getCreateOrgUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createOrgResponse
}



/**
 * Super admin only. Returns a paginated list of all organizations on the platform.
 * @summary List organizations (platform-wide)
 */
export type listOrgsResponse200 = {
  data: PagedOrgs
  status: 200
}

export type listOrgsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listOrgsResponseSuccess = (listOrgsResponse200) & {
  headers: Headers;
};
export type listOrgsResponseError = (listOrgsResponse401 | listOrgsResponse403) & {
  headers: Headers;
};

export type listOrgsResponse = (listOrgsResponseSuccess | listOrgsResponseError)

export const getListOrgsUrl = (params?: ListOrgsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs?${stringifiedParams}` : `/orgs`
}

export const listOrgs = async (params?: ListOrgsParams, options?: RequestInit): Promise<listOrgsResponse> => {
  
  const res = await fetch(getListOrgsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgsResponse
}



/**
 * Returns the details of a single organization.
 * @summary Get org details
 */
export type getOrgResponse200 = {
  data: Org
  status: 200
}

export type getOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgResponseSuccess = (getOrgResponse200) & {
  headers: Headers;
};
export type getOrgResponseError = (getOrgResponse401 | getOrgResponse403 | getOrgResponse404) & {
  headers: Headers;
};

export type getOrgResponse = (getOrgResponseSuccess | getOrgResponseError)

export const getGetOrgUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}`
}

export const getOrg = async (orgId: string, options?: RequestInit): Promise<getOrgResponse> => {
  
  const res = await fetch(getGetOrgUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgResponse
}



/**
 * Partially updates an organization's profile fields.
 * @summary Update org details
 */
export type updateOrgResponse200 = {
  data: Org
  status: 200
}

export type updateOrgResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgResponseSuccess = (updateOrgResponse200) & {
  headers: Headers;
};
export type updateOrgResponseError = (updateOrgResponse400 | updateOrgResponse401 | updateOrgResponse403 | updateOrgResponse404) & {
  headers: Headers;
};

export type updateOrgResponse = (updateOrgResponseSuccess | updateOrgResponseError)

export const getUpdateOrgUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}`
}

export const updateOrg = async (orgId: string,
    orgUpdateRequest: OrgUpdateRequest, options?: RequestInit): Promise<updateOrgResponse> => {
  
  const res = await fetch(getUpdateOrgUrl(orgId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgResponse
}



/**
 * Returns the settings for an organization (join policies, default roles, etc.).
 * @summary Read org settings
 */
export type getOrgSettingsResponse200 = {
  data: OrgSettings
  status: 200
}

export type getOrgSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgSettingsResponseSuccess = (getOrgSettingsResponse200) & {
  headers: Headers;
};
export type getOrgSettingsResponseError = (getOrgSettingsResponse401 | getOrgSettingsResponse403 | getOrgSettingsResponse404) & {
  headers: Headers;
};

export type getOrgSettingsResponse = (getOrgSettingsResponseSuccess | getOrgSettingsResponseError)

export const getGetOrgSettingsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/settings`
}

export const getOrgSettings = async (orgId: string, options?: RequestInit): Promise<getOrgSettingsResponse> => {
  
  const res = await fetch(getGetOrgSettingsUrl(orgId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgSettingsResponse
}



/**
 * Partially updates the organization's settings.
 * @summary Update org settings
 */
export type updateOrgSettingsResponse200 = {
  data: OrgSettings
  status: 200
}

export type updateOrgSettingsResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgSettingsResponseSuccess = (updateOrgSettingsResponse200) & {
  headers: Headers;
};
export type updateOrgSettingsResponseError = (updateOrgSettingsResponse400 | updateOrgSettingsResponse401 | updateOrgSettingsResponse403 | updateOrgSettingsResponse404) & {
  headers: Headers;
};

export type updateOrgSettingsResponse = (updateOrgSettingsResponseSuccess | updateOrgSettingsResponseError)

export const getUpdateOrgSettingsUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/settings`
}

export const updateOrgSettings = async (orgId: string,
    orgSettingsUpdateRequest: OrgSettingsUpdateRequest, options?: RequestInit): Promise<updateOrgSettingsResponse> => {
  
  const res = await fetch(getUpdateOrgSettingsUrl(orgId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgSettingsUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgSettingsResponse
}



/**
 * Returns a paginated list of staff members for the organization.
 * @summary List org members (staff)
 */
export type listOrgMembersResponse200 = {
  data: PagedOrgMembers
  status: 200
}

export type listOrgMembersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgMembersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listOrgMembersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listOrgMembersResponseSuccess = (listOrgMembersResponse200) & {
  headers: Headers;
};
export type listOrgMembersResponseError = (listOrgMembersResponse401 | listOrgMembersResponse403 | listOrgMembersResponse404) & {
  headers: Headers;
};

export type listOrgMembersResponse = (listOrgMembersResponseSuccess | listOrgMembersResponseError)

export const getListOrgMembersUrl = (orgId: string,
    params?: ListOrgMembersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/members?${stringifiedParams}` : `/orgs/${orgId}/members`
}

export const listOrgMembers = async (orgId: string,
    params?: ListOrgMembersParams, options?: RequestInit): Promise<listOrgMembersResponse> => {
  
  const res = await fetch(getListOrgMembersUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgMembersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgMembersResponse
}



/**
 * Returns the membership details for a specific staff member.
 * @summary Get membership record (role, status)
 */
export type getOrgMemberResponse200 = {
  data: OrgMember
  status: 200
}

export type getOrgMemberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgMemberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgMemberResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgMemberResponseSuccess = (getOrgMemberResponse200) & {
  headers: Headers;
};
export type getOrgMemberResponseError = (getOrgMemberResponse401 | getOrgMemberResponse403 | getOrgMemberResponse404) & {
  headers: Headers;
};

export type getOrgMemberResponse = (getOrgMemberResponseSuccess | getOrgMemberResponseError)

export const getGetOrgMemberUrl = (orgId: string,
    memberId: string,) => {


  

  return `/orgs/${orgId}/members/${memberId}`
}

export const getOrgMember = async (orgId: string,
    memberId: string, options?: RequestInit): Promise<getOrgMemberResponse> => {
  
  const res = await fetch(getGetOrgMemberUrl(orgId,memberId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgMemberResponse
}



/**
 * Updates a member's role or status within the organization.
 * @summary Update membership record (e.g., role/admin)
 */
export type updateOrgMemberResponse200 = {
  data: OrgMember
  status: 200
}

export type updateOrgMemberResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgMemberResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgMemberResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgMemberResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgMemberResponseSuccess = (updateOrgMemberResponse200) & {
  headers: Headers;
};
export type updateOrgMemberResponseError = (updateOrgMemberResponse400 | updateOrgMemberResponse401 | updateOrgMemberResponse403 | updateOrgMemberResponse404) & {
  headers: Headers;
};

export type updateOrgMemberResponse = (updateOrgMemberResponseSuccess | updateOrgMemberResponseError)

export const getUpdateOrgMemberUrl = (orgId: string,
    memberId: string,) => {


  

  return `/orgs/${orgId}/members/${memberId}`
}

export const updateOrgMember = async (orgId: string,
    memberId: string,
    orgMemberUpdateRequest: OrgMemberUpdateRequest, options?: RequestInit): Promise<updateOrgMemberResponse> => {
  
  const res = await fetch(getUpdateOrgMemberUrl(orgId,memberId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgMemberUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgMemberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgMemberResponse
}



/**
 * Submits a request for a user to join an organization, or an admin invite on behalf of a user.
 * @summary Request to join org (or admin invite)
 */
export type createMembershipRequestResponse201 = {
  data: MembershipRequest
  status: 201
}

export type createMembershipRequestResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createMembershipRequestResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type createMembershipRequestResponseSuccess = (createMembershipRequestResponse201) & {
  headers: Headers;
};
export type createMembershipRequestResponseError = (createMembershipRequestResponse400 | createMembershipRequestResponse401 | createMembershipRequestResponse403 | createMembershipRequestResponse409) & {
  headers: Headers;
};

export type createMembershipRequestResponse = (createMembershipRequestResponseSuccess | createMembershipRequestResponseError)

export const getCreateMembershipRequestUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/membership-requests`
}

export const createMembershipRequest = async (orgId: string,
    membershipRequestCreate: MembershipRequestCreate, options?: RequestInit): Promise<createMembershipRequestResponse> => {
  
  const res = await fetch(getCreateMembershipRequestUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      membershipRequestCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createMembershipRequestResponse
}



/**
 * Returns pending, approved, and rejected membership requests for admin review.
 * @summary List membership requests for org (admin review)
 */
export type listMembershipRequestsResponse200 = {
  data: PagedMembershipRequests
  status: 200
}

export type listMembershipRequestsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listMembershipRequestsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listMembershipRequestsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listMembershipRequestsResponseSuccess = (listMembershipRequestsResponse200) & {
  headers: Headers;
};
export type listMembershipRequestsResponseError = (listMembershipRequestsResponse401 | listMembershipRequestsResponse403 | listMembershipRequestsResponse404) & {
  headers: Headers;
};

export type listMembershipRequestsResponse = (listMembershipRequestsResponseSuccess | listMembershipRequestsResponseError)

export const getListMembershipRequestsUrl = (orgId: string,
    params?: ListMembershipRequestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/membership-requests?${stringifiedParams}` : `/orgs/${orgId}/membership-requests`
}

export const listMembershipRequests = async (orgId: string,
    params?: ListMembershipRequestsParams, options?: RequestInit): Promise<listMembershipRequestsResponse> => {
  
  const res = await fetch(getListMembershipRequestsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listMembershipRequestsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listMembershipRequestsResponse
}



/**
 * Approves a pending membership request, creating the org member record.
 * @summary Approve membership request
 */
export type approveMembershipRequestResponse200 = {
  data: OrgMember
  status: 200
}

export type approveMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type approveMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type approveMembershipRequestResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type approveMembershipRequestResponseSuccess = (approveMembershipRequestResponse200) & {
  headers: Headers;
};
export type approveMembershipRequestResponseError = (approveMembershipRequestResponse401 | approveMembershipRequestResponse403 | approveMembershipRequestResponse404) & {
  headers: Headers;
};

export type approveMembershipRequestResponse = (approveMembershipRequestResponseSuccess | approveMembershipRequestResponseError)

export const getApproveMembershipRequestUrl = (orgId: string,
    requestId: string,) => {


  

  return `/orgs/${orgId}/membership-requests/${requestId}/approve`
}

export const approveMembershipRequest = async (orgId: string,
    requestId: string, options?: RequestInit): Promise<approveMembershipRequestResponse> => {
  
  const res = await fetch(getApproveMembershipRequestUrl(orgId,requestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: approveMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as approveMembershipRequestResponse
}



/**
 * Rejects a pending membership request.
 * @summary Reject membership request
 */
export type rejectMembershipRequestResponse204 = {
  data: void
  status: 204
}

export type rejectMembershipRequestResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type rejectMembershipRequestResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type rejectMembershipRequestResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type rejectMembershipRequestResponseSuccess = (rejectMembershipRequestResponse204) & {
  headers: Headers;
};
export type rejectMembershipRequestResponseError = (rejectMembershipRequestResponse401 | rejectMembershipRequestResponse403 | rejectMembershipRequestResponse404) & {
  headers: Headers;
};

export type rejectMembershipRequestResponse = (rejectMembershipRequestResponseSuccess | rejectMembershipRequestResponseError)

export const getRejectMembershipRequestUrl = (orgId: string,
    requestId: string,) => {


  

  return `/orgs/${orgId}/membership-requests/${requestId}/reject`
}

export const rejectMembershipRequest = async (orgId: string,
    requestId: string, options?: RequestInit): Promise<rejectMembershipRequestResponse> => {
  
  const res = await fetch(getRejectMembershipRequestUrl(orgId,requestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rejectMembershipRequestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rejectMembershipRequestResponse
}



/**
 * Returns a paginated list of learners provisioned in this organization.
 * @summary List learners affiliated with org
 */
export type listOrgLearnersResponse200 = {
  data: PagedOrgLearners
  status: 200
}

export type listOrgLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listOrgLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listOrgLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listOrgLearnersResponseSuccess = (listOrgLearnersResponse200) & {
  headers: Headers;
};
export type listOrgLearnersResponseError = (listOrgLearnersResponse401 | listOrgLearnersResponse403 | listOrgLearnersResponse404) & {
  headers: Headers;
};

export type listOrgLearnersResponse = (listOrgLearnersResponseSuccess | listOrgLearnersResponseError)

export const getListOrgLearnersUrl = (orgId: string,
    params?: ListOrgLearnersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/learners?${stringifiedParams}` : `/orgs/${orgId}/learners`
}

export const listOrgLearners = async (orgId: string,
    params?: ListOrgLearnersParams, options?: RequestInit): Promise<listOrgLearnersResponse> => {
  
  const res = await fetch(getListOrgLearnersUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOrgLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOrgLearnersResponse
}



/**
 * Creates a new learner record affiliated with this organization.
 * @summary Provision a learner in this org
 */
export type createOrgLearnerResponse201 = {
  data: OrgLearner
  status: 201
}

export type createOrgLearnerResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createOrgLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createOrgLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createOrgLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createOrgLearnerResponseSuccess = (createOrgLearnerResponse201) & {
  headers: Headers;
};
export type createOrgLearnerResponseError = (createOrgLearnerResponse400 | createOrgLearnerResponse401 | createOrgLearnerResponse403 | createOrgLearnerResponse404) & {
  headers: Headers;
};

export type createOrgLearnerResponse = (createOrgLearnerResponseSuccess | createOrgLearnerResponseError)

export const getCreateOrgLearnerUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/learners`
}

export const createOrgLearner = async (orgId: string,
    orgLearnerCreateRequest: OrgLearnerCreateRequest, options?: RequestInit): Promise<createOrgLearnerResponse> => {
  
  const res = await fetch(getCreateOrgLearnerUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      orgLearnerCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createOrgLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createOrgLearnerResponse
}



/**
 * Accepts a batch of learner records and queues them for import.
 * @summary Bulk import learners for org
 */
export type bulkImportOrgLearnersResponse202 = {
  data: ImportJob
  status: 202
}

export type bulkImportOrgLearnersResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type bulkImportOrgLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type bulkImportOrgLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type bulkImportOrgLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type bulkImportOrgLearnersResponseSuccess = (bulkImportOrgLearnersResponse202) & {
  headers: Headers;
};
export type bulkImportOrgLearnersResponseError = (bulkImportOrgLearnersResponse400 | bulkImportOrgLearnersResponse401 | bulkImportOrgLearnersResponse403 | bulkImportOrgLearnersResponse404) & {
  headers: Headers;
};

export type bulkImportOrgLearnersResponse = (bulkImportOrgLearnersResponseSuccess | bulkImportOrgLearnersResponseError)

export const getBulkImportOrgLearnersUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/learners:bulk-import`
}

export const bulkImportOrgLearners = async (orgId: string,
    bulkLearnerImportRequest: BulkLearnerImportRequest, options?: RequestInit): Promise<bulkImportOrgLearnersResponse> => {
  
  const res = await fetch(getBulkImportOrgLearnersUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkLearnerImportRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: bulkImportOrgLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as bulkImportOrgLearnersResponse
}



/**
 * Returns learner details including badge progress and issuances scoped to this organization.
 * @summary Get learner details as it pertains to this org
 */
export type getOrgLearnerResponse200 = {
  data: OrgLearnerDetail
  status: 200
}

export type getOrgLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgLearnerResponseSuccess = (getOrgLearnerResponse200) & {
  headers: Headers;
};
export type getOrgLearnerResponseError = (getOrgLearnerResponse401 | getOrgLearnerResponse403 | getOrgLearnerResponse404) & {
  headers: Headers;
};

export type getOrgLearnerResponse = (getOrgLearnerResponseSuccess | getOrgLearnerResponseError)

export const getGetOrgLearnerUrl = (orgId: string,
    learnerId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}`
}

export const getOrgLearner = async (orgId: string,
    learnerId: string, options?: RequestInit): Promise<getOrgLearnerResponse> => {
  
  const res = await fetch(getGetOrgLearnerUrl(orgId,learnerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgLearnerResponse
}



/**
 * Returns the learner's progress on a specific badge within this organization.
 * @summary Get learner progress toward badge (org-scoped)
 */
export type getOrgLearnerBadgeProgressResponse200 = {
  data: BadgeProgress
  status: 200
}

export type getOrgLearnerBadgeProgressResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getOrgLearnerBadgeProgressResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getOrgLearnerBadgeProgressResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getOrgLearnerBadgeProgressResponseSuccess = (getOrgLearnerBadgeProgressResponse200) & {
  headers: Headers;
};
export type getOrgLearnerBadgeProgressResponseError = (getOrgLearnerBadgeProgressResponse401 | getOrgLearnerBadgeProgressResponse403 | getOrgLearnerBadgeProgressResponse404) & {
  headers: Headers;
};

export type getOrgLearnerBadgeProgressResponse = (getOrgLearnerBadgeProgressResponseSuccess | getOrgLearnerBadgeProgressResponseError)

export const getGetOrgLearnerBadgeProgressUrl = (orgId: string,
    learnerId: string,
    badgeId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/badges/${badgeId}`
}

export const getOrgLearnerBadgeProgress = async (orgId: string,
    learnerId: string,
    badgeId: string, options?: RequestInit): Promise<getOrgLearnerBadgeProgressResponse> => {
  
  const res = await fetch(getGetOrgLearnerBadgeProgressUrl(orgId,learnerId,badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getOrgLearnerBadgeProgressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getOrgLearnerBadgeProgressResponse
}



/**
 * Updates the learner's progress on a badge, such as marking criteria complete.
 * @summary Update learner progress toward badge (org-scoped)
 */
export type updateOrgLearnerBadgeProgressResponse200 = {
  data: BadgeProgress
  status: 200
}

export type updateOrgLearnerBadgeProgressResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateOrgLearnerBadgeProgressResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateOrgLearnerBadgeProgressResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateOrgLearnerBadgeProgressResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateOrgLearnerBadgeProgressResponseSuccess = (updateOrgLearnerBadgeProgressResponse200) & {
  headers: Headers;
};
export type updateOrgLearnerBadgeProgressResponseError = (updateOrgLearnerBadgeProgressResponse400 | updateOrgLearnerBadgeProgressResponse401 | updateOrgLearnerBadgeProgressResponse403 | updateOrgLearnerBadgeProgressResponse404) & {
  headers: Headers;
};

export type updateOrgLearnerBadgeProgressResponse = (updateOrgLearnerBadgeProgressResponseSuccess | updateOrgLearnerBadgeProgressResponseError)

export const getUpdateOrgLearnerBadgeProgressUrl = (orgId: string,
    learnerId: string,
    badgeId: string,) => {


  

  return `/orgs/${orgId}/learners/${learnerId}/badges/${badgeId}`
}

export const updateOrgLearnerBadgeProgress = async (orgId: string,
    learnerId: string,
    badgeId: string,
    badgeProgressUpdateRequest: BadgeProgressUpdateRequest, options?: RequestInit): Promise<updateOrgLearnerBadgeProgressResponse> => {
  
  const res = await fetch(getUpdateOrgLearnerBadgeProgressUrl(orgId,learnerId,badgeId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeProgressUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateOrgLearnerBadgeProgressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateOrgLearnerBadgeProgressResponse
}



/**
 * Issues a badge to a learner, creating a verifiable assertion record.
 * @summary Issue a badge to a learner (creates Assertion)
 */
export type createIssuanceResponse201 = {
  data: Issuance
  status: 201
}

export type createIssuanceResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createIssuanceResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createIssuanceResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createIssuanceResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createIssuanceResponseSuccess = (createIssuanceResponse201) & {
  headers: Headers;
};
export type createIssuanceResponseError = (createIssuanceResponse400 | createIssuanceResponse401 | createIssuanceResponse403 | createIssuanceResponse404) & {
  headers: Headers;
};

export type createIssuanceResponse = (createIssuanceResponseSuccess | createIssuanceResponseError)

export const getCreateIssuanceUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/issuances`
}

export const createIssuance = async (orgId: string,
    issuanceCreateRequest: IssuanceCreateRequest, options?: RequestInit): Promise<createIssuanceResponse> => {
  
  const res = await fetch(getCreateIssuanceUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      issuanceCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createIssuanceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createIssuanceResponse
}



/**
 * Returns a paginated list of badge issuances for this organization, with optional filters.
 * @summary List issuances for org
 */
export type listIssuancesResponse200 = {
  data: PagedIssuances
  status: 200
}

export type listIssuancesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listIssuancesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listIssuancesResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listIssuancesResponseSuccess = (listIssuancesResponse200) & {
  headers: Headers;
};
export type listIssuancesResponseError = (listIssuancesResponse401 | listIssuancesResponse403 | listIssuancesResponse404) & {
  headers: Headers;
};

export type listIssuancesResponse = (listIssuancesResponseSuccess | listIssuancesResponseError)

export const getListIssuancesUrl = (orgId: string,
    params?: ListIssuancesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/issuances?${stringifiedParams}` : `/orgs/${orgId}/issuances`
}

export const listIssuances = async (orgId: string,
    params?: ListIssuancesParams, options?: RequestInit): Promise<listIssuancesResponse> => {
  
  const res = await fetch(getListIssuancesUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listIssuancesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listIssuancesResponse
}



/**
 * Returns a paginated list of cohorts for this organization.
 * @summary List cohorts
 */
export type listCohortsResponse200 = {
  data: PagedCohorts
  status: 200
}

export type listCohortsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listCohortsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listCohortsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listCohortsResponseSuccess = (listCohortsResponse200) & {
  headers: Headers;
};
export type listCohortsResponseError = (listCohortsResponse401 | listCohortsResponse403 | listCohortsResponse404) & {
  headers: Headers;
};

export type listCohortsResponse = (listCohortsResponseSuccess | listCohortsResponseError)

export const getListCohortsUrl = (orgId: string,
    params?: ListCohortsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orgs/${orgId}/cohorts?${stringifiedParams}` : `/orgs/${orgId}/cohorts`
}

export const listCohorts = async (orgId: string,
    params?: ListCohortsParams, options?: RequestInit): Promise<listCohortsResponse> => {
  
  const res = await fetch(getListCohortsUrl(orgId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCohortsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCohortsResponse
}



/**
 * Creates a new learner cohort within the organization.
 * @summary Create cohort
 */
export type createCohortResponse201 = {
  data: Cohort
  status: 201
}

export type createCohortResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type createCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type createCohortResponseSuccess = (createCohortResponse201) & {
  headers: Headers;
};
export type createCohortResponseError = (createCohortResponse400 | createCohortResponse401 | createCohortResponse403 | createCohortResponse404) & {
  headers: Headers;
};

export type createCohortResponse = (createCohortResponseSuccess | createCohortResponseError)

export const getCreateCohortUrl = (orgId: string,) => {


  

  return `/orgs/${orgId}/cohorts`
}

export const createCohort = async (orgId: string,
    cohortCreateRequest: CohortCreateRequest, options?: RequestInit): Promise<createCohortResponse> => {
  
  const res = await fetch(getCreateCohortUrl(orgId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCohortResponse
}



/**
 * Returns full cohort details including the list of learners in this cohort.
 * @summary Get cohort details (including learner constituents)
 */
export type getCohortResponse200 = {
  data: CohortDetail
  status: 200
}

export type getCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getCohortResponseSuccess = (getCohortResponse200) & {
  headers: Headers;
};
export type getCohortResponseError = (getCohortResponse401 | getCohortResponse403 | getCohortResponse404) & {
  headers: Headers;
};

export type getCohortResponse = (getCohortResponseSuccess | getCohortResponseError)

export const getGetCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const getCohort = async (orgId: string,
    cohortId: string, options?: RequestInit): Promise<getCohortResponse> => {
  
  const res = await fetch(getGetCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCohortResponse
}



/**
 * Partially updates a cohort's name or description.
 * @summary Update cohort
 */
export type updateCohortResponse200 = {
  data: Cohort
  status: 200
}

export type updateCohortResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateCohortResponseSuccess = (updateCohortResponse200) & {
  headers: Headers;
};
export type updateCohortResponseError = (updateCohortResponse400 | updateCohortResponse401 | updateCohortResponse403 | updateCohortResponse404) & {
  headers: Headers;
};

export type updateCohortResponse = (updateCohortResponseSuccess | updateCohortResponseError)

export const getUpdateCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const updateCohort = async (orgId: string,
    cohortId: string,
    cohortUpdateRequest: CohortUpdateRequest, options?: RequestInit): Promise<updateCohortResponse> => {
  
  const res = await fetch(getUpdateCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCohortResponse
}



/**
 * Permanently deletes a cohort. Learners are not removed from the organization.
 * @summary Delete cohort
 */
export type deleteCohortResponse204 = {
  data: void
  status: 204
}

export type deleteCohortResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteCohortResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteCohortResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteCohortResponseSuccess = (deleteCohortResponse204) & {
  headers: Headers;
};
export type deleteCohortResponseError = (deleteCohortResponse401 | deleteCohortResponse403 | deleteCohortResponse404) & {
  headers: Headers;
};

export type deleteCohortResponse = (deleteCohortResponseSuccess | deleteCohortResponseError)

export const getDeleteCohortUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}`
}

export const deleteCohort = async (orgId: string,
    cohortId: string, options?: RequestInit): Promise<deleteCohortResponse> => {
  
  const res = await fetch(getDeleteCohortUrl(orgId,cohortId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCohortResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCohortResponse
}



/**
 * Adds one or more learners to a cohort by their IDs.
 * @summary Add learners to cohort (batch)
 */
export type addCohortLearnersResponse200 = {
  data: CohortDetail
  status: 200
}

export type addCohortLearnersResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type addCohortLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type addCohortLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type addCohortLearnersResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type addCohortLearnersResponseSuccess = (addCohortLearnersResponse200) & {
  headers: Headers;
};
export type addCohortLearnersResponseError = (addCohortLearnersResponse400 | addCohortLearnersResponse401 | addCohortLearnersResponse403 | addCohortLearnersResponse404) & {
  headers: Headers;
};

export type addCohortLearnersResponse = (addCohortLearnersResponseSuccess | addCohortLearnersResponseError)

export const getAddCohortLearnersUrl = (orgId: string,
    cohortId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/learners`
}

export const addCohortLearners = async (orgId: string,
    cohortId: string,
    cohortLearnersAddRequest: CohortLearnersAddRequest, options?: RequestInit): Promise<addCohortLearnersResponse> => {
  
  const res = await fetch(getAddCohortLearnersUrl(orgId,cohortId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      cohortLearnersAddRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addCohortLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addCohortLearnersResponse
}



/**
 * Removes a single learner from a cohort.
 * @summary Remove learner from cohort
 */
export type removeCohortLearnerResponse204 = {
  data: void
  status: 204
}

export type removeCohortLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type removeCohortLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type removeCohortLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type removeCohortLearnerResponseSuccess = (removeCohortLearnerResponse204) & {
  headers: Headers;
};
export type removeCohortLearnerResponseError = (removeCohortLearnerResponse401 | removeCohortLearnerResponse403 | removeCohortLearnerResponse404) & {
  headers: Headers;
};

export type removeCohortLearnerResponse = (removeCohortLearnerResponseSuccess | removeCohortLearnerResponseError)

export const getRemoveCohortLearnerUrl = (orgId: string,
    cohortId: string,
    learnerId: string,) => {


  

  return `/orgs/${orgId}/cohorts/${cohortId}/learners/${learnerId}`
}

export const removeCohortLearner = async (orgId: string,
    cohortId: string,
    learnerId: string, options?: RequestInit): Promise<removeCohortLearnerResponse> => {
  
  const res = await fetch(getRemoveCohortLearnerUrl(orgId,cohortId,learnerId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeCohortLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeCohortLearnerResponse
}



/**
 * Super admin only. Returns a paginated list of all user accounts.
 * @summary List users (platform-wide)
 */
export type listUsersResponse200 = {
  data: PagedUsers
  status: 200
}

export type listUsersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listUsersResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listUsersResponseSuccess = (listUsersResponse200) & {
  headers: Headers;
};
export type listUsersResponseError = (listUsersResponse401 | listUsersResponse403) & {
  headers: Headers;
};

export type listUsersResponse = (listUsersResponseSuccess | listUsersResponseError)

export const getListUsersUrl = (params?: ListUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/users?${stringifiedParams}` : `/users`
}

export const listUsers = async (params?: ListUsersParams, options?: RequestInit): Promise<listUsersResponse> => {
  
  const res = await fetch(getListUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsersResponse
}



/**
 * Returns the user's profile information.
 * @summary Get user details (profile)
 */
export type getUserResponse200 = {
  data: User
  status: 200
}

export type getUserResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUserResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUserResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getUserResponseSuccess = (getUserResponse200) & {
  headers: Headers;
};
export type getUserResponseError = (getUserResponse401 | getUserResponse403 | getUserResponse404) & {
  headers: Headers;
};

export type getUserResponse = (getUserResponseSuccess | getUserResponseError)

export const getGetUserUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const getUser = async (userId: string, options?: RequestInit): Promise<getUserResponse> => {
  
  const res = await fetch(getGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserResponse
}



/**
 * Returns the user's preferences (locale, marketing opt-in, etc.).
 * @summary Get user settings
 */
export type getUserSettingsResponse200 = {
  data: UserSettings
  status: 200
}

export type getUserSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getUserSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getUserSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getUserSettingsResponseSuccess = (getUserSettingsResponse200) & {
  headers: Headers;
};
export type getUserSettingsResponseError = (getUserSettingsResponse401 | getUserSettingsResponse403 | getUserSettingsResponse404) & {
  headers: Headers;
};

export type getUserSettingsResponse = (getUserSettingsResponseSuccess | getUserSettingsResponseError)

export const getGetUserSettingsUrl = (userId: string,) => {


  

  return `/users/${userId}/settings`
}

export const getUserSettings = async (userId: string, options?: RequestInit): Promise<getUserSettingsResponse> => {
  
  const res = await fetch(getGetUserSettingsUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserSettingsResponse
}



/**
 * Partially updates the user's preferences.
 * @summary Update user settings
 */
export type updateUserSettingsResponse200 = {
  data: UserSettings
  status: 200
}

export type updateUserSettingsResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateUserSettingsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateUserSettingsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateUserSettingsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateUserSettingsResponseSuccess = (updateUserSettingsResponse200) & {
  headers: Headers;
};
export type updateUserSettingsResponseError = (updateUserSettingsResponse400 | updateUserSettingsResponse401 | updateUserSettingsResponse403 | updateUserSettingsResponse404) & {
  headers: Headers;
};

export type updateUserSettingsResponse = (updateUserSettingsResponseSuccess | updateUserSettingsResponseError)

export const getUpdateUserSettingsUrl = (userId: string,) => {


  

  return `/users/${userId}/settings`
}

export const updateUserSettings = async (userId: string,
    userSettingsUpdateRequest: UserSettingsUpdateRequest, options?: RequestInit): Promise<updateUserSettingsResponse> => {
  
  const res = await fetch(getUpdateUserSettingsUrl(userId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSettingsUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserSettingsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserSettingsResponse
}



/**
 * Super admin only. Returns a paginated list of all learner records.
 * @summary List learners (platform-wide)
 */
export type listLearnersResponse200 = {
  data: PagedLearners
  status: 200
}

export type listLearnersResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listLearnersResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listLearnersResponseSuccess = (listLearnersResponse200) & {
  headers: Headers;
};
export type listLearnersResponseError = (listLearnersResponse401 | listLearnersResponse403) & {
  headers: Headers;
};

export type listLearnersResponse = (listLearnersResponseSuccess | listLearnersResponseError)

export const getListLearnersUrl = (params?: ListLearnersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/learners?${stringifiedParams}` : `/learners`
}

export const listLearners = async (params?: ListLearnersParams, options?: RequestInit): Promise<listLearnersResponse> => {
  
  const res = await fetch(getListLearnersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listLearnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listLearnersResponse
}



/**
 * Returns a learner's global profile, independent of any organization.
 * @summary Get learner details (global)
 */
export type getLearnerResponse200 = {
  data: Learner
  status: 200
}

export type getLearnerResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getLearnerResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getLearnerResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getLearnerResponseSuccess = (getLearnerResponse200) & {
  headers: Headers;
};
export type getLearnerResponseError = (getLearnerResponse401 | getLearnerResponse403 | getLearnerResponse404) & {
  headers: Headers;
};

export type getLearnerResponse = (getLearnerResponseSuccess | getLearnerResponseError)

export const getGetLearnerUrl = (learnerId: string,) => {


  

  return `/learners/${learnerId}`
}

export const getLearner = async (learnerId: string, options?: RequestInit): Promise<getLearnerResponse> => {
  
  const res = await fetch(getGetLearnerUrl(learnerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLearnerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLearnerResponse
}



/**
 * Returns a paginated list of all badges a learner has earned or is working toward across all orgs.
 * @summary List badges earned or in progress (global aggregation)
 */
export type listLearnerBadgesResponse200 = {
  data: PagedLearnerBadges
  status: 200
}

export type listLearnerBadgesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listLearnerBadgesResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listLearnerBadgesResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listLearnerBadgesResponseSuccess = (listLearnerBadgesResponse200) & {
  headers: Headers;
};
export type listLearnerBadgesResponseError = (listLearnerBadgesResponse401 | listLearnerBadgesResponse403 | listLearnerBadgesResponse404) & {
  headers: Headers;
};

export type listLearnerBadgesResponse = (listLearnerBadgesResponseSuccess | listLearnerBadgesResponseError)

export const getListLearnerBadgesUrl = (learnerId: string,
    params?: ListLearnerBadgesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/learners/${learnerId}/badges?${stringifiedParams}` : `/learners/${learnerId}/badges`
}

export const listLearnerBadges = async (learnerId: string,
    params?: ListLearnerBadgesParams, options?: RequestInit): Promise<listLearnerBadgesResponse> => {
  
  const res = await fetch(getListLearnerBadgesUrl(learnerId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listLearnerBadgesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listLearnerBadgesResponse
}



/**
 * Returns the learner's full journey for a badge â€” progress across orgs, and any assertions earned. Used for shareable certificate pages.
 * @summary Learner journey for a specific badge
 */
export type getLearnerBadgeJourneyResponse200 = {
  data: LearnerBadgeJourney
  status: 200
}

export type getLearnerBadgeJourneyResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getLearnerBadgeJourneyResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getLearnerBadgeJourneyResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getLearnerBadgeJourneyResponseSuccess = (getLearnerBadgeJourneyResponse200) & {
  headers: Headers;
};
export type getLearnerBadgeJourneyResponseError = (getLearnerBadgeJourneyResponse401 | getLearnerBadgeJourneyResponse403 | getLearnerBadgeJourneyResponse404) & {
  headers: Headers;
};

export type getLearnerBadgeJourneyResponse = (getLearnerBadgeJourneyResponseSuccess | getLearnerBadgeJourneyResponseError)

export const getGetLearnerBadgeJourneyUrl = (learnerId: string,
    badgeId: string,) => {


  

  return `/learners/${learnerId}/badges/${badgeId}`
}

export const getLearnerBadgeJourney = async (learnerId: string,
    badgeId: string, options?: RequestInit): Promise<getLearnerBadgeJourneyResponse> => {
  
  const res = await fetch(getGetLearnerBadgeJourneyUrl(learnerId,badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getLearnerBadgeJourneyResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getLearnerBadgeJourneyResponse
}



/**
 * Returns a paginated list of badge definitions, optionally filtered by creating org.
 * @summary List badges
 */
export type listBadgesResponse200 = {
  data: PagedBadges
  status: 200
}

export type listBadgesResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listBadgesResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listBadgesResponseSuccess = (listBadgesResponse200) & {
  headers: Headers;
};
export type listBadgesResponseError = (listBadgesResponse401 | listBadgesResponse403) & {
  headers: Headers;
};

export type listBadgesResponse = (listBadgesResponseSuccess | listBadgesResponseError)

export const getListBadgesUrl = (params?: ListBadgesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/badges?${stringifiedParams}` : `/badges`
}

export const listBadges = async (params?: ListBadgesParams, options?: RequestInit): Promise<listBadgesResponse> => {
  
  const res = await fetch(getListBadgesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBadgesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBadgesResponse
}



/**
 * Creates a new badge definition with optional criteria.
 * @summary Create a badge
 */
export type createBadgeResponse201 = {
  data: Badge
  status: 201
}

export type createBadgeResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createBadgeResponseSuccess = (createBadgeResponse201) & {
  headers: Headers;
};
export type createBadgeResponseError = (createBadgeResponse400 | createBadgeResponse401 | createBadgeResponse403) & {
  headers: Headers;
};

export type createBadgeResponse = (createBadgeResponseSuccess | createBadgeResponseError)

export const getCreateBadgeUrl = () => {


  

  return `/badges`
}

export const createBadge = async (badgeCreateRequest: BadgeCreateRequest, options?: RequestInit): Promise<createBadgeResponse> => {
  
  const res = await fetch(getCreateBadgeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createBadgeResponse
}



/**
 * Returns the full badge definition including criteria.
 * @summary Get badge details (Open Badges-aligned)
 */
export type getBadgeResponse200 = {
  data: Badge
  status: 200
}

export type getBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getBadgeResponseSuccess = (getBadgeResponse200) & {
  headers: Headers;
};
export type getBadgeResponseError = (getBadgeResponse401 | getBadgeResponse403 | getBadgeResponse404) & {
  headers: Headers;
};

export type getBadgeResponse = (getBadgeResponseSuccess | getBadgeResponseError)

export const getGetBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const getBadge = async (badgeId: string, options?: RequestInit): Promise<getBadgeResponse> => {
  
  const res = await fetch(getGetBadgeUrl(badgeId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getBadgeResponse
}



/**
 * Partially updates a badge's name, description, image, or criteria.
 * @summary Update badge
 */
export type updateBadgeResponse200 = {
  data: Badge
  status: 200
}

export type updateBadgeResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateBadgeResponseSuccess = (updateBadgeResponse200) & {
  headers: Headers;
};
export type updateBadgeResponseError = (updateBadgeResponse400 | updateBadgeResponse401 | updateBadgeResponse403 | updateBadgeResponse404) & {
  headers: Headers;
};

export type updateBadgeResponse = (updateBadgeResponseSuccess | updateBadgeResponseError)

export const getUpdateBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const updateBadge = async (badgeId: string,
    badgeUpdateRequest: BadgeUpdateRequest, options?: RequestInit): Promise<updateBadgeResponse> => {
  
  const res = await fetch(getUpdateBadgeUrl(badgeId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      badgeUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateBadgeResponse
}



/**
 * Permanently deletes a badge definition. Existing issuances are not affected.
 * @summary Delete badge
 */
export type deleteBadgeResponse204 = {
  data: void
  status: 204
}

export type deleteBadgeResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteBadgeResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteBadgeResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteBadgeResponseSuccess = (deleteBadgeResponse204) & {
  headers: Headers;
};
export type deleteBadgeResponseError = (deleteBadgeResponse401 | deleteBadgeResponse403 | deleteBadgeResponse404) & {
  headers: Headers;
};

export type deleteBadgeResponse = (deleteBadgeResponseSuccess | deleteBadgeResponseError)

export const getDeleteBadgeUrl = (badgeId: string,) => {


  

  return `/badges/${badgeId}`
}

export const deleteBadge = async (badgeId: string, options?: RequestInit): Promise<deleteBadgeResponse> => {
  
  const res = await fetch(getDeleteBadgeUrl(badgeId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteBadgeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteBadgeResponse
}



/**
 * Returns a paginated list of badge collections.
 * @summary List collections
 */
export type listCollectionsResponse200 = {
  data: PagedCollections
  status: 200
}

export type listCollectionsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listCollectionsResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type listCollectionsResponseSuccess = (listCollectionsResponse200) & {
  headers: Headers;
};
export type listCollectionsResponseError = (listCollectionsResponse401 | listCollectionsResponse403) & {
  headers: Headers;
};

export type listCollectionsResponse = (listCollectionsResponseSuccess | listCollectionsResponseError)

export const getListCollectionsUrl = (params?: ListCollectionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/collections?${stringifiedParams}` : `/collections`
}

export const listCollections = async (params?: ListCollectionsParams, options?: RequestInit): Promise<listCollectionsResponse> => {
  
  const res = await fetch(getListCollectionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCollectionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCollectionsResponse
}



/**
 * Creates a new collection of badges.
 * @summary Create collection
 */
export type createCollectionResponse201 = {
  data: Collection
  status: 201
}

export type createCollectionResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type createCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type createCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}
    
export type createCollectionResponseSuccess = (createCollectionResponse201) & {
  headers: Headers;
};
export type createCollectionResponseError = (createCollectionResponse400 | createCollectionResponse401 | createCollectionResponse403) & {
  headers: Headers;
};

export type createCollectionResponse = (createCollectionResponseSuccess | createCollectionResponseError)

export const getCreateCollectionUrl = () => {


  

  return `/collections`
}

export const createCollection = async (collectionCreateRequest: CollectionCreateRequest, options?: RequestInit): Promise<createCollectionResponse> => {
  
  const res = await fetch(getCreateCollectionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionCreateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCollectionResponse
}



/**
 * Returns the collection and summaries of the badges it contains.
 * @summary Get collection details (includes some badge details)
 */
export type getCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type getCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type getCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type getCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getCollectionResponseSuccess = (getCollectionResponse200) & {
  headers: Headers;
};
export type getCollectionResponseError = (getCollectionResponse401 | getCollectionResponse403 | getCollectionResponse404) & {
  headers: Headers;
};

export type getCollectionResponse = (getCollectionResponseSuccess | getCollectionResponseError)

export const getGetCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const getCollection = async (collectionId: string, options?: RequestInit): Promise<getCollectionResponse> => {
  
  const res = await fetch(getGetCollectionUrl(collectionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCollectionResponse
}



/**
 * Partially updates a collection's metadata and/or its badge membership.
 * @summary Update collection (including add/remove badges)
 */
export type updateCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type updateCollectionResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type updateCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type updateCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type updateCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type updateCollectionResponseSuccess = (updateCollectionResponse200) & {
  headers: Headers;
};
export type updateCollectionResponseError = (updateCollectionResponse400 | updateCollectionResponse401 | updateCollectionResponse403 | updateCollectionResponse404) & {
  headers: Headers;
};

export type updateCollectionResponse = (updateCollectionResponseSuccess | updateCollectionResponseError)

export const getUpdateCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const updateCollection = async (collectionId: string,
    collectionUpdateRequest: CollectionUpdateRequest, options?: RequestInit): Promise<updateCollectionResponse> => {
  
  const res = await fetch(getUpdateCollectionUrl(collectionId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionUpdateRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCollectionResponse
}



/**
 * Permanently deletes a collection. Badges within it are not deleted.
 * @summary Delete collection
 */
export type deleteCollectionResponse204 = {
  data: void
  status: 204
}

export type deleteCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type deleteCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type deleteCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type deleteCollectionResponseSuccess = (deleteCollectionResponse204) & {
  headers: Headers;
};
export type deleteCollectionResponseError = (deleteCollectionResponse401 | deleteCollectionResponse403 | deleteCollectionResponse404) & {
  headers: Headers;
};

export type deleteCollectionResponse = (deleteCollectionResponseSuccess | deleteCollectionResponseError)

export const getDeleteCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}`
}

export const deleteCollection = async (collectionId: string, options?: RequestInit): Promise<deleteCollectionResponse> => {
  
  const res = await fetch(getDeleteCollectionUrl(collectionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCollectionResponse
}



/**
 * Public browsing of published collections. No authentication required.
 * @summary Browse published collections in registry
 */
export type browseRegistryResponse200 = {
  data: PagedCollections
  status: 200
}
    
export type browseRegistryResponseSuccess = (browseRegistryResponse200) & {
  headers: Headers;
};
;

export type browseRegistryResponse = (browseRegistryResponseSuccess)

export const getBrowseRegistryUrl = (params?: BrowseRegistryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/registry/collections?${stringifiedParams}` : `/registry/collections`
}

export const browseRegistry = async (params?: BrowseRegistryParams, options?: RequestInit): Promise<browseRegistryResponse> => {
  
  const res = await fetch(getBrowseRegistryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: browseRegistryResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as browseRegistryResponse
}



/**
 * Makes a collection visible in the public registry.
 * @summary Publish a collection to registry
 */
export type publishCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type publishCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type publishCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type publishCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type publishCollectionResponseSuccess = (publishCollectionResponse200) & {
  headers: Headers;
};
export type publishCollectionResponseError = (publishCollectionResponse401 | publishCollectionResponse403 | publishCollectionResponse404) & {
  headers: Headers;
};

export type publishCollectionResponse = (publishCollectionResponseSuccess | publishCollectionResponseError)

export const getPublishCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/publish`
}

export const publishCollection = async (collectionId: string, options?: RequestInit): Promise<publishCollectionResponse> => {
  
  const res = await fetch(getPublishCollectionUrl(collectionId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: publishCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as publishCollectionResponse
}



/**
 * Removes a collection from the public registry.
 * @summary Unpublish a collection from registry
 */
export type unpublishCollectionResponse200 = {
  data: CollectionDetail
  status: 200
}

export type unpublishCollectionResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type unpublishCollectionResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type unpublishCollectionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type unpublishCollectionResponseSuccess = (unpublishCollectionResponse200) & {
  headers: Headers;
};
export type unpublishCollectionResponseError = (unpublishCollectionResponse401 | unpublishCollectionResponse403 | unpublishCollectionResponse404) & {
  headers: Headers;
};

export type unpublishCollectionResponse = (unpublishCollectionResponseSuccess | unpublishCollectionResponseError)

export const getUnpublishCollectionUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/unpublish`
}

export const unpublishCollection = async (collectionId: string, options?: RequestInit): Promise<unpublishCollectionResponse> => {
  
  const res = await fetch(getUnpublishCollectionUrl(collectionId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unpublishCollectionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unpublishCollectionResponse
}



/**
 * An org requests permission from the collection creator to issue its badges.
 * @summary Request authorization for an org to issue a collection
 */
export type requestIssueAuthorizationResponse201 = {
  data: IssueAuthorizationRequest
  status: 201
}

export type requestIssueAuthorizationResponse400 = {
  data: BadRequestResponse
  status: 400
}

export type requestIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type requestIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type requestIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}

export type requestIssueAuthorizationResponse409 = {
  data: ErrorResponse
  status: 409
}
    
export type requestIssueAuthorizationResponseSuccess = (requestIssueAuthorizationResponse201) & {
  headers: Headers;
};
export type requestIssueAuthorizationResponseError = (requestIssueAuthorizationResponse400 | requestIssueAuthorizationResponse401 | requestIssueAuthorizationResponse403 | requestIssueAuthorizationResponse404 | requestIssueAuthorizationResponse409) & {
  headers: Headers;
};

export type requestIssueAuthorizationResponse = (requestIssueAuthorizationResponseSuccess | requestIssueAuthorizationResponseError)

export const getRequestIssueAuthorizationUrl = (collectionId: string,) => {


  

  return `/collections/${collectionId}/issue-authorizations`
}

export const requestIssueAuthorization = async (collectionId: string,
    issueAuthorizationRequestCreate: IssueAuthorizationRequestCreate, options?: RequestInit): Promise<requestIssueAuthorizationResponse> => {
  
  const res = await fetch(getRequestIssueAuthorizationUrl(collectionId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      issueAuthorizationRequestCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: requestIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as requestIssueAuthorizationResponse
}



/**
 * Returns authorization requests for the collection, for the creator to review.
 * @summary List authorization requests for this collection (creator review)
 */
export type listIssueAuthorizationsResponse200 = {
  data: PagedIssueAuthorizationRequests
  status: 200
}

export type listIssueAuthorizationsResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type listIssueAuthorizationsResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type listIssueAuthorizationsResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type listIssueAuthorizationsResponseSuccess = (listIssueAuthorizationsResponse200) & {
  headers: Headers;
};
export type listIssueAuthorizationsResponseError = (listIssueAuthorizationsResponse401 | listIssueAuthorizationsResponse403 | listIssueAuthorizationsResponse404) & {
  headers: Headers;
};

export type listIssueAuthorizationsResponse = (listIssueAuthorizationsResponseSuccess | listIssueAuthorizationsResponseError)

export const getListIssueAuthorizationsUrl = (collectionId: string,
    params?: ListIssueAuthorizationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/collections/${collectionId}/issue-authorizations?${stringifiedParams}` : `/collections/${collectionId}/issue-authorizations`
}

export const listIssueAuthorizations = async (collectionId: string,
    params?: ListIssueAuthorizationsParams, options?: RequestInit): Promise<listIssueAuthorizationsResponse> => {
  
  const res = await fetch(getListIssueAuthorizationsUrl(collectionId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listIssueAuthorizationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listIssueAuthorizationsResponse
}



/**
 * Grants an org the authorization to issue badges from the collection.
 * @summary Approve issue authorization request
 */
export type approveIssueAuthorizationResponse200 = {
  data: IssueAuthorization
  status: 200
}

export type approveIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type approveIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type approveIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type approveIssueAuthorizationResponseSuccess = (approveIssueAuthorizationResponse200) & {
  headers: Headers;
};
export type approveIssueAuthorizationResponseError = (approveIssueAuthorizationResponse401 | approveIssueAuthorizationResponse403 | approveIssueAuthorizationResponse404) & {
  headers: Headers;
};

export type approveIssueAuthorizationResponse = (approveIssueAuthorizationResponseSuccess | approveIssueAuthorizationResponseError)

export const getApproveIssueAuthorizationUrl = (authRequestId: string,) => {


  

  return `/issue-authorizations/${authRequestId}/approve`
}

export const approveIssueAuthorization = async (authRequestId: string, options?: RequestInit): Promise<approveIssueAuthorizationResponse> => {
  
  const res = await fetch(getApproveIssueAuthorizationUrl(authRequestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: approveIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as approveIssueAuthorizationResponse
}



/**
 * Denies an org's request to issue badges from the collection.
 * @summary Reject issue authorization request
 */
export type rejectIssueAuthorizationResponse204 = {
  data: void
  status: 204
}

export type rejectIssueAuthorizationResponse401 = {
  data: UnauthorizedResponse
  status: 401
}

export type rejectIssueAuthorizationResponse403 = {
  data: ForbiddenResponse
  status: 403
}

export type rejectIssueAuthorizationResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type rejectIssueAuthorizationResponseSuccess = (rejectIssueAuthorizationResponse204) & {
  headers: Headers;
};
export type rejectIssueAuthorizationResponseError = (rejectIssueAuthorizationResponse401 | rejectIssueAuthorizationResponse403 | rejectIssueAuthorizationResponse404) & {
  headers: Headers;
};

export type rejectIssueAuthorizationResponse = (rejectIssueAuthorizationResponseSuccess | rejectIssueAuthorizationResponseError)

export const getRejectIssueAuthorizationUrl = (authRequestId: string,) => {


  

  return `/issue-authorizations/${authRequestId}/reject`
}

export const rejectIssueAuthorization = async (authRequestId: string, options?: RequestInit): Promise<rejectIssueAuthorizationResponse> => {
  
  const res = await fetch(getRejectIssueAuthorizationUrl(authRequestId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rejectIssueAuthorizationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rejectIssueAuthorizationResponse
}



/**
 * Returns the publicly verifiable assertion data for an issued badge. No authentication required.
 * @summary Public verification payload for an issued badge (Assertion)
 */
export type getPublicAssertionResponse200 = {
  data: Assertion
  status: 200
}

export type getPublicAssertionResponse404 = {
  data: NotFoundResponse
  status: 404
}
    
export type getPublicAssertionResponseSuccess = (getPublicAssertionResponse200) & {
  headers: Headers;
};
export type getPublicAssertionResponseError = (getPublicAssertionResponse404) & {
  headers: Headers;
};

export type getPublicAssertionResponse = (getPublicAssertionResponseSuccess | getPublicAssertionResponseError)

export const getGetPublicAssertionUrl = (assertionId: string,) => {


  

  return `/public/assertions/${assertionId}`
}

export const getPublicAssertion = async (assertionId: string, options?: RequestInit): Promise<getPublicAssertionResponse> => {
  
  const res = await fetch(getGetPublicAssertionUrl(assertionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getPublicAssertionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getPublicAssertionResponse
}


export const getRegisterResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getLoginResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getRefreshTokenResponseMock = (overrideResponse: Partial< AuthResponse > = {}): AuthResponse => ({accessToken: faker.string.alpha({length: {min: 10, max: 20}}), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), user: {id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, ...overrideResponse})

export const getCreateOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListOrgsResponseMock = (overrideResponse: Partial< PagedOrgs > = {}): PagedOrgs => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgResponseMock = (overrideResponse: Partial< Org > = {}): Org => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), about: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), contactEmail: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetOrgSettingsResponseMock = (overrideResponse: Partial< OrgSettings > = {}): OrgSettings => ({allowSelfJoin: faker.datatype.boolean(), requireAdminApprovalForJoin: faker.datatype.boolean(), defaultMemberRole: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getUpdateOrgSettingsResponseMock = (overrideResponse: Partial< OrgSettings > = {}): OrgSettings => ({allowSelfJoin: faker.datatype.boolean(), requireAdminApprovalForJoin: faker.datatype.boolean(), defaultMemberRole: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getListOrgMembersResponseMock = (overrideResponse: Partial< PagedOrgMembers > = {}): PagedOrgMembers => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetOrgMemberResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgMemberResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getCreateMembershipRequestResponseMock = (overrideResponse: Partial< MembershipRequest > = {}): MembershipRequest => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected','canceled'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListMembershipRequestsResponseMock = (overrideResponse: Partial< PagedMembershipRequests > = {}): PagedMembershipRequests => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected','canceled'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getApproveMembershipRequestResponseMock = (overrideResponse: Partial< OrgMember > = {}): OrgMember => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), userId: faker.string.alpha({length: {min: 10, max: 20}}), role: faker.helpers.arrayElement(['owner','admin','issuer','viewer'] as const), status: faker.helpers.arrayElement(['active','invited','suspended'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListOrgLearnersResponseMock = (overrideResponse: Partial< PagedOrgLearners > = {}): PagedOrgLearners => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, undefined]), badgeProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), issuances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), undefined])},})), ...overrideResponse})

export const getCreateOrgLearnerResponseMock = (overrideResponse: Partial< OrgLearner > = {}): OrgLearner => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getBulkImportOrgLearnersResponseMock = (overrideResponse: Partial< ImportJob > = {}): ImportJob => ({id: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['queued','running','complete','failed'] as const), totalCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), successCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), errorCount: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), errors: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), ...overrideResponse})

export const getGetOrgLearnerResponseMock = (): OrgLearnerDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), externalRef: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), status: faker.helpers.arrayElement(['active','archived'] as const), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learner: faker.helpers.arrayElement([{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, undefined]), badgeProgress: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), issuances: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), undefined])},})

export const getGetOrgLearnerBadgeProgressResponseMock = (overrideResponse: Partial< BadgeProgress > = {}): BadgeProgress => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateOrgLearnerBadgeProgressResponseMock = (overrideResponse: Partial< BadgeProgress > = {}): BadgeProgress => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getCreateIssuanceResponseMock = (overrideResponse: Partial< Issuance > = {}): Issuance => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined]), ...overrideResponse})

export const getListIssuancesResponseMock = (overrideResponse: Partial< PagedIssuances > = {}): PagedIssuances => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), assertionId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['issued','revoked'] as const), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', revokedAt: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z',null,]), undefined])})), ...overrideResponse})

export const getListCohortsResponseMock = (overrideResponse: Partial< PagedCohorts > = {}): PagedCohorts => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateCohortResponseMock = (overrideResponse: Partial< Cohort > = {}): Cohort => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetCohortResponseMock = (): CohortDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learners: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined])},})

export const getUpdateCohortResponseMock = (overrideResponse: Partial< Cohort > = {}): Cohort => ({id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getAddCohortLearnersResponseMock = (): CohortDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{learners: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined])},})

export const getListUsersResponseMock = (overrideResponse: Partial< PagedUsers > = {}): PagedUsers => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetUserResponseMock = (overrideResponse: Partial< User > = {}): User => ({id: faker.string.alpha({length: {min: 10, max: 20}}), email: faker.internet.email(), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetUserSettingsResponseMock = (overrideResponse: Partial< UserSettings > = {}): UserSettings => ({locale: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), marketingEmails: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getUpdateUserSettingsResponseMock = (overrideResponse: Partial< UserSettings > = {}): UserSettings => ({locale: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), marketingEmails: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), ...overrideResponse})

export const getListLearnersResponseMock = (overrideResponse: Partial< PagedLearners > = {}): PagedLearners => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getGetLearnerResponseMock = (overrideResponse: Partial< Learner > = {}): Learner => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.internet.email(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListLearnerBadgesResponseMock = (overrideResponse: Partial< PagedLearnerBadges > = {}): PagedLearnerBadges => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, progressByOrg: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), assertions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])})), ...overrideResponse})

export const getGetLearnerBadgeJourneyResponseMock = (overrideResponse: Partial< LearnerBadgeJourney > = {}): LearnerBadgeJourney => ({learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badge: {id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])}, progressByOrg: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({orgId: faker.string.alpha({length: {min: 10, max: 20}}), learnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['not_started','in_progress','complete'] as const), completedCriteriaIds: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha({length: {min: 10, max: 20}}))), undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), undefined]), assertions: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined]), ...overrideResponse})

export const getListBadgesResponseMock = (overrideResponse: Partial< PagedBadges > = {}): PagedBadges => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getUpdateBadgeResponseMock = (overrideResponse: Partial< Badge > = {}): Badge => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), criteria: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), isRequired: faker.helpers.arrayElement([faker.datatype.boolean(), undefined])})), undefined]), createdByOrgId: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListCollectionsResponseMock = (overrideResponse: Partial< PagedCollections > = {}): PagedCollections => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getCreateCollectionResponseMock = (overrideResponse: Partial< Collection > = {}): Collection => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])},})

export const getUpdateCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])},})

export const getBrowseRegistryResponseMock = (overrideResponse: Partial< PagedCollections > = {}): PagedCollections => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getPublishCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])},})

export const getUnpublishCollectionResponseMock = (): CollectionDetail => ({...{id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), description: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdByOrgId: faker.string.alpha({length: {min: 10, max: 20}}), published: faker.helpers.arrayElement([faker.datatype.boolean(), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), updatedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])},...{badgeSummaries: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), imageUrl: faker.helpers.arrayElement([faker.internet.url(), undefined])})), undefined])},})

export const getRequestIssueAuthorizationResponseMock = (overrideResponse: Partial< IssueAuthorizationRequest > = {}): IssueAuthorizationRequest => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), requestingOrgId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getListIssueAuthorizationsResponseMock = (overrideResponse: Partial< PagedIssueAuthorizationRequests > = {}): PagedIssueAuthorizationRequests => ({meta: {page: faker.number.int({min: undefined, max: undefined}), pageSize: faker.number.int({min: undefined, max: undefined}), total: faker.number.int({min: undefined, max: undefined})}, data: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), requestingOrgId: faker.string.alpha({length: {min: 10, max: 20}}), status: faker.helpers.arrayElement(['pending','approved','rejected'] as const), message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), createdAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined])})), ...overrideResponse})

export const getApproveIssueAuthorizationResponseMock = (overrideResponse: Partial< IssueAuthorization > = {}): IssueAuthorization => ({id: faker.string.alpha({length: {min: 10, max: 20}}), collectionId: faker.string.alpha({length: {min: 10, max: 20}}), orgId: faker.string.alpha({length: {min: 10, max: 20}}), grantedAt: faker.helpers.arrayElement([faker.date.past().toISOString().slice(0, 19) + 'Z', undefined]), ...overrideResponse})

export const getGetPublicAssertionResponseMock = (overrideResponse: Partial< Assertion > = {}): Assertion => ({id: faker.string.alpha({length: {min: 10, max: 20}}), issuerOrgId: faker.string.alpha({length: {min: 10, max: 20}}), recipientLearnerId: faker.string.alpha({length: {min: 10, max: 20}}), badgeId: faker.string.alpha({length: {min: 10, max: 20}}), issuedAt: faker.date.past().toISOString().slice(0, 19) + 'Z', evidenceUrl: faker.helpers.arrayElement([faker.internet.url(), undefined]), ...overrideResponse})


export const getRegisterMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/register', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRegisterResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getLoginMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/login', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRefreshTokenMockHandler = (overrideResponse?: AuthResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<AuthResponse> | AuthResponse), options?: RequestHandlerOptions) => {
  return http.post('*/auth/refresh', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRefreshTokenResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getLogoutMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/auth/logout', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getCreateOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.post('*/auth/createorg', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateOrgResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgsMockHandler = (overrideResponse?: PagedOrgs | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgs> | PagedOrgs), options?: RequestHandlerOptions) => {
  return http.get('*/orgs', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgMockHandler = (overrideResponse?: Org | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Org> | Org), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgSettingsMockHandler = (overrideResponse?: OrgSettings | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgSettings> | OrgSettings), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgSettingsMockHandler = (overrideResponse?: OrgSettings | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<OrgSettings> | OrgSettings), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListOrgMembersMockHandler = (overrideResponse?: PagedOrgMembers | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgMembers> | PagedOrgMembers), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/members', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgMembersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgMemberMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/members/:memberId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgMemberResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgMemberMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/members/:memberId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgMemberResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateMembershipRequestMockHandler = (overrideResponse?: MembershipRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<MembershipRequest> | MembershipRequest), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateMembershipRequestResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListMembershipRequestsMockHandler = (overrideResponse?: PagedMembershipRequests | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedMembershipRequests> | PagedMembershipRequests), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/membership-requests', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListMembershipRequestsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApproveMembershipRequestMockHandler = (overrideResponse?: OrgMember | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<OrgMember> | OrgMember), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests/:requestId/approve', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApproveMembershipRequestResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRejectMembershipRequestMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/membership-requests/:requestId/reject', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListOrgLearnersMockHandler = (overrideResponse?: PagedOrgLearners | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedOrgLearners> | PagedOrgLearners), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListOrgLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateOrgLearnerMockHandler = (overrideResponse?: OrgLearner | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<OrgLearner> | OrgLearner), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateOrgLearnerResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getBulkImportOrgLearnersMockHandler = (overrideResponse?: ImportJob | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<ImportJob> | ImportJob), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/learners\:bulk-import', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getBulkImportOrgLearnersResponseMock()),
      { status: 202,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgLearnerMockHandler = (overrideResponse?: OrgLearnerDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<OrgLearnerDetail> | OrgLearnerDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgLearnerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetOrgLearnerBadgeProgressMockHandler = (overrideResponse?: BadgeProgress | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<BadgeProgress> | BadgeProgress), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetOrgLearnerBadgeProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateOrgLearnerBadgeProgressMockHandler = (overrideResponse?: BadgeProgress | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<BadgeProgress> | BadgeProgress), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateOrgLearnerBadgeProgressResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateIssuanceMockHandler = (overrideResponse?: Issuance | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Issuance> | Issuance), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/issuances', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateIssuanceResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListIssuancesMockHandler = (overrideResponse?: PagedIssuances | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedIssuances> | PagedIssuances), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/issuances', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListIssuancesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListCohortsMockHandler = (overrideResponse?: PagedCohorts | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCohorts> | PagedCohorts), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListCohortsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateCohortMockHandler = (overrideResponse?: Cohort | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Cohort> | Cohort), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/cohorts', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateCohortResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetCohortMockHandler = (overrideResponse?: CohortDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CohortDetail> | CohortDetail), options?: RequestHandlerOptions) => {
  return http.get('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetCohortResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateCohortMockHandler = (overrideResponse?: Cohort | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Cohort> | Cohort), options?: RequestHandlerOptions) => {
  return http.patch('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateCohortResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteCohortMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/cohorts/:cohortId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getAddCohortLearnersMockHandler = (overrideResponse?: CohortDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CohortDetail> | CohortDetail), options?: RequestHandlerOptions) => {
  return http.post('*/orgs/:orgId/cohorts/:cohortId/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getAddCohortLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRemoveCohortLearnerMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/orgs/:orgId/cohorts/:cohortId/learners/:learnerId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListUsersMockHandler = (overrideResponse?: PagedUsers | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedUsers> | PagedUsers), options?: RequestHandlerOptions) => {
  return http.get('*/users', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetUserMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User), options?: RequestHandlerOptions) => {
  return http.get('*/users/:userId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetUserSettingsMockHandler = (overrideResponse?: UserSettings | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserSettings> | UserSettings), options?: RequestHandlerOptions) => {
  return http.get('*/users/:userId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateUserSettingsMockHandler = (overrideResponse?: UserSettings | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UserSettings> | UserSettings), options?: RequestHandlerOptions) => {
  return http.patch('*/users/:userId/settings', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateUserSettingsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListLearnersMockHandler = (overrideResponse?: PagedLearners | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedLearners> | PagedLearners), options?: RequestHandlerOptions) => {
  return http.get('*/learners', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListLearnersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetLearnerMockHandler = (overrideResponse?: Learner | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Learner> | Learner), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetLearnerResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListLearnerBadgesMockHandler = (overrideResponse?: PagedLearnerBadges | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedLearnerBadges> | PagedLearnerBadges), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListLearnerBadgesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetLearnerBadgeJourneyMockHandler = (overrideResponse?: LearnerBadgeJourney | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<LearnerBadgeJourney> | LearnerBadgeJourney), options?: RequestHandlerOptions) => {
  return http.get('*/learners/:learnerId/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetLearnerBadgeJourneyResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListBadgesMockHandler = (overrideResponse?: PagedBadges | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedBadges> | PagedBadges), options?: RequestHandlerOptions) => {
  return http.get('*/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListBadgesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.post('*/badges', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateBadgeResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.get('*/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetBadgeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateBadgeMockHandler = (overrideResponse?: Badge | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Badge> | Badge), options?: RequestHandlerOptions) => {
  return http.patch('*/badges/:badgeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateBadgeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteBadgeMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/badges/:badgeId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getListCollectionsMockHandler = (overrideResponse?: PagedCollections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCollections> | PagedCollections), options?: RequestHandlerOptions) => {
  return http.get('*/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListCollectionsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getCreateCollectionMockHandler = (overrideResponse?: Collection | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Collection> | Collection), options?: RequestHandlerOptions) => {
  return http.post('*/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getCreateCollectionResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getGetCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.get('*/collections/:collectionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUpdateCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.patch('*/collections/:collectionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getDeleteCollectionMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.delete('*/collections/:collectionId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getBrowseRegistryMockHandler = (overrideResponse?: PagedCollections | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedCollections> | PagedCollections), options?: RequestHandlerOptions) => {
  return http.get('*/registry/collections', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getBrowseRegistryResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getPublishCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/publish', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPublishCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getUnpublishCollectionMockHandler = (overrideResponse?: CollectionDetail | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CollectionDetail> | CollectionDetail), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/unpublish', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUnpublishCollectionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRequestIssueAuthorizationMockHandler = (overrideResponse?: IssueAuthorizationRequest | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<IssueAuthorizationRequest> | IssueAuthorizationRequest), options?: RequestHandlerOptions) => {
  return http.post('*/collections/:collectionId/issue-authorizations', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRequestIssueAuthorizationResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getListIssueAuthorizationsMockHandler = (overrideResponse?: PagedIssueAuthorizationRequests | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<PagedIssueAuthorizationRequests> | PagedIssueAuthorizationRequests), options?: RequestHandlerOptions) => {
  return http.get('*/collections/:collectionId/issue-authorizations', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getListIssueAuthorizationsResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getApproveIssueAuthorizationMockHandler = (overrideResponse?: IssueAuthorization | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<IssueAuthorization> | IssueAuthorization), options?: RequestHandlerOptions) => {
  return http.post('*/issue-authorizations/:authRequestId/approve', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getApproveIssueAuthorizationResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}

export const getRejectIssueAuthorizationMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<void> | void), options?: RequestHandlerOptions) => {
  return http.post('*/issue-authorizations/:authRequestId/reject', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  }, options)
}

export const getGetPublicAssertionMockHandler = (overrideResponse?: Assertion | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Assertion> | Assertion), options?: RequestHandlerOptions) => {
  return http.get('*/public/assertions/:assertionId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetPublicAssertionResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  }, options)
}
export const getBadgingAppAPIV0Mock = () => [
  getRegisterMockHandler(),
  getLoginMockHandler(),
  getRefreshTokenMockHandler(),
  getLogoutMockHandler(),
  getCreateOrgMockHandler(),
  getListOrgsMockHandler(),
  getGetOrgMockHandler(),
  getUpdateOrgMockHandler(),
  getGetOrgSettingsMockHandler(),
  getUpdateOrgSettingsMockHandler(),
  getListOrgMembersMockHandler(),
  getGetOrgMemberMockHandler(),
  getUpdateOrgMemberMockHandler(),
  getCreateMembershipRequestMockHandler(),
  getListMembershipRequestsMockHandler(),
  getApproveMembershipRequestMockHandler(),
  getRejectMembershipRequestMockHandler(),
  getListOrgLearnersMockHandler(),
  getCreateOrgLearnerMockHandler(),
  getBulkImportOrgLearnersMockHandler(),
  getGetOrgLearnerMockHandler(),
  getGetOrgLearnerBadgeProgressMockHandler(),
  getUpdateOrgLearnerBadgeProgressMockHandler(),
  getCreateIssuanceMockHandler(),
  getListIssuancesMockHandler(),
  getListCohortsMockHandler(),
  getCreateCohortMockHandler(),
  getGetCohortMockHandler(),
  getUpdateCohortMockHandler(),
  getDeleteCohortMockHandler(),
  getAddCohortLearnersMockHandler(),
  getRemoveCohortLearnerMockHandler(),
  getListUsersMockHandler(),
  getGetUserMockHandler(),
  getGetUserSettingsMockHandler(),
  getUpdateUserSettingsMockHandler(),
  getListLearnersMockHandler(),
  getGetLearnerMockHandler(),
  getListLearnerBadgesMockHandler(),
  getGetLearnerBadgeJourneyMockHandler(),
  getListBadgesMockHandler(),
  getCreateBadgeMockHandler(),
  getGetBadgeMockHandler(),
  getUpdateBadgeMockHandler(),
  getDeleteBadgeMockHandler(),
  getListCollectionsMockHandler(),
  getCreateCollectionMockHandler(),
  getGetCollectionMockHandler(),
  getUpdateCollectionMockHandler(),
  getDeleteCollectionMockHandler(),
  getBrowseRegistryMockHandler(),
  getPublishCollectionMockHandler(),
  getUnpublishCollectionMockHandler(),
  getRequestIssueAuthorizationMockHandler(),
  getListIssueAuthorizationsMockHandler(),
  getApproveIssueAuthorizationMockHandler(),
  getRejectIssueAuthorizationMockHandler(),
  getGetPublicAssertionMockHandler()
]
